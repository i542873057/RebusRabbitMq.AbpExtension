<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Activation.BuiltinHandlerActivator">
            <summary>
            Built-in handler activator that can be used when dependency injection is not required, or when inline
            lambda-based handler are wanted
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Returns all relevant handler instances for the given message by looking up compatible registered functions and instance factory methods.
            </summary>
        </member>
        <member name="P:Rebus.Activation.BuiltinHandlerActivator.Bus">
            <summary>
            Gets the bus instance that this activator was configured with
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.SetBus(Rebus.Bus.IBus)">
            <summary>
            Stores the bus instance
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> and the current <see cref="T:Rebus.Pipeline.IMessageContext"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Dispose">
            <summary>
            Disposes the contained bus instance
            </summary>
        </member>
        <member name="T:Rebus.Activation.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.Activation.IHandlerActivator"/> with the expectation that it is backed by some kind of IoC container that can hold
            a bus instance (which it naturally should be able to inject into handlers when they're activated)
            </summary>
        </member>
        <member name="M:Rebus.Activation.IContainerAdapter.SetBus(Rebus.Bus.IBus)">
            <summary>
            Sets the bus instance that this <see cref="T:Rebus.Activation.IContainerAdapter"/> should be able to inject when resolving handler instances
            </summary>
        </member>
        <member name="T:Rebus.Activation.IHandlerActivator">
            <summary>
            Responsible for creating handlers for a given message type
            </summary>
        </member>
        <member name="M:Rebus.Activation.IHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Must return all relevant handler instances for the given message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.AuditHeaders">
            <summary>
            Headers relevant when using message auditing
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.AuditTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message copy was forwarded to the audit queue.
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the audited message was received.
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleQueue">
            <summary>
            Header with the queue name from which the message was received. 
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.MachineName">
            <summary>
            Name of the machine that processed/published the message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.IncomingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.IncomingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions.EnableMessageAuditing(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.OutgoingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.OutgoingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage">
            <summary>
            Saga snapshot storage that archives a snapshot of the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.ISagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Archives the given saga data under its current ID and revision
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.EnableSagaAuditing(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables saga auditing which will cause Rebus to save a snapshot of each saga state to the configured snapshot storage.
            Please remember to select a saga snapshot storage by calling an extension on the returned <see cref="T:Rebus.Config.StandardConfigurer`1"/>, e.g. like so:
            <code>
            Configure.With(..)
                .(...)
                .Options(o => o.EnableSagaAuditing().StoreInSqlServer(....))
                .Start();
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.OutputToLog(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage})">
            <summary>
            Configures Rebus to output saga snapshots to the log. Each saga data mutation will be logged as a serialized JSON object without type information
            with INFO level to the class-logger of <see cref="T:Rebus.Auditing.Sagas.LoggerSagaSnapperShotter"/>.
            This is probably mostly useful in debugging scenarios, or as a simple auditing mechanism in cases where sagas don't expect a lot of traffic.
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys">
            <summary>
            Contains keys of metadata elements that can be found alongside saga data snapshots when saga auditing has been enabled
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.HandleQueue">
            <summary>
            Key of the input queue address of the endpoint that handled the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaDataType">
            <summary>
            Key of the type of the saga data
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaHandlerType">
            <summary>
            Key of the type of the saga handler that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageType">
            <summary>
            Key of the type of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageId">
            <summary>
            Key of the ID of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MachineName">
            <summary>
            Key of the machine name on which the saga data was brought to the current state
            </summary>
        </member>
        <member name="T:Rebus.Backoff.BackoffConfigurationExtensions">
            <summary>
            Configuration extensions for customizing the backoff behavior
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.TimeSpan[])">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            The implementations of the advanced APIs are private classes inside <see cref="T:Rebus.Bus.RebusBus"/> so that they can access private functions and stuff
            </summary>
            <summary>
            This is the main bus thing which you'll most likely hold on to
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.Workers.IWorkerFactory,Rebus.Routing.IRouter,Rebus.Transport.ITransport,Rebus.Pipeline.IPipelineInvoker,Rebus.Subscriptions.ISubscriptionStorage,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Bus.BusLifetimeEvents,Rebus.DataBus.IDataBus)">
            <summary>
            Constructs the bus.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the bus by adding the specified number of workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if
            called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerPublish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified event message on the specified topic, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerSubscribe(System.String)">
            <summary>
            Subscribes to the specified topic. If the current subscription storage is centralized, the subscription will be established right away. Otherwise, a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerUnsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified topic. If the current subscription storage is centralized, the subscription will be removed right away. Otherwise, an <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, allowing them to finish handling the current message (for up to 1 minute) before exiting
            </summary>
        </member>
        <member name="E:Rebus.Bus.RebusBus.Disposed">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers by adding/removing one worker at a time until
            the desired number is reached
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Gets a label for this bus instance - e.g. "RebusBus 2" if this is the 2nd instance created, ever, in the current process
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes a task synchronously on the calling thread by installing a temporary synchronization context that queues continuations
             </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext">
            <summary>
            Synchronization context that can be "pumped" in order to have it execute continuations posted back to it
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.AsyncHelpers.CustomSynchronizationContext.Run">
            <summary>
            Enqueues the function to be executed and executes all resulting continuations until it is completely done
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IAdvancedApi">
            <summary>
            API for the advanced features of the bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Workers">
            <summary>
            Gets an API to query/control various aspects around Rebus' workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Topics">
            <summary>
            Gets an API to do pub/sub on raw string-based topics
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Routing">
            <summary>
            Gets an API to explicitly route messages
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.TransportMessage">
            <summary>
            Gets an API to perform operations with the transport message currently being handled
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.DataBus">
            <summary>
            Gets the API for the data bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.SyncBus">
            <summary>
            Exposes a synchronous version of <see cref="T:Rebus.Bus.IBus"/> that essentially mimics all APIs only providing them in a synchronous version
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IRoutingApi">
            <summary>
            Provides a raw API for explicitly routing messages to other endpoints
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Send(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.SendRoutingSlip(Rebus.Routing.Itinerary,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the message as a routing slip that will visit the destinations specified by the given <see cref="T:Rebus.Routing.Itinerary"/>
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ISyncBus">
            <summary>
            Synchronous API for all of the async-native operations of the Rebus <see cref="T:Rebus.Bus.IBus"/>. May be used in applications 
            that need to perform bus operations deep within a call hierarchy, or that simply do not contain an appropriate place
            to await something. Safe to use in applications that insist on running continuations on the initiating thread, like 
            e.g. ASP.NET and WPF.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ISyncBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITopicsApi">
            <summary>
            Provides the raw topic-based pub/sub API which is used underneath the type-based pub/sub api provided by <see cref="T:Rebus.Bus.IBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Publish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified message to the specified topic. Default behavior is to look up the addresses of those who subscribed to the given topic
            by calling <see cref="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)"/> but the transport may override this behavior if it has special capabilities.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Subscribe(System.String)">
            <summary>
            Subscribes the current endpoint to the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is registered immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and a
            <see cref="T:Rebus.Messages.Control.SubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the current endpoint from the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is removed immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and an
            <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITransportMessageApi">
            <summary>
            Contains operations that can be performed on the transport message currently being handled
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Forward(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Forwards the transport message currently being handled to the specified queue, optionally supplying some extra headers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the transport message currently being handled some time into the future, optionally specifying some additional headers
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IWorkersApi">
            <summary>
            Defines an API for working with workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IWorkersApi.Count">
            <summary>
            Gets how many workers are currently running
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IWorkersApi.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers, blocking until the desired number has been reached
            </summary>
        </member>
        <member name="T:Rebus.Bus.BusLifetimeEvents">
            <summary>
            Has events that can be subscribed to if one wants to be notified when certain things happen
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarting">
            <summary>
            Event that is raised when the bus is starting BEFORE the bus adds any workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusStarted">
            <summary>
            Event that is raised when the bus is starting AFTER the bus hass added its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposing">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            BEFORE the bus stops its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.WorkersStopped">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event, AFTER the bus has stopped all workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposed">
            <summary>
            Event that is raised when the bus is disposed AFTER the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            </summary>
        </member>
        <member name="T:Rebus.Bus.IBus">
            <summary>
            This is the main bus API
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the bus instance's own input queue address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.DeferredRecipient"/> is specified
            in a header, the endpoint mapping corresponding to the sent message will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="P:Rebus.Bus.IBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.IInitializable">
            <summary>
            Anything that is resolved with the injectionist can be marked as initializable by implementing this interface, which
            will then have its <see cref="M:Rebus.Bus.IInitializable.Initialize"/> method called before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.Bus.IInitializable.Initialize">
            <summary>
            Initializes the instance
            </summary>
        </member>
        <member name="T:Rebus.Bus.MessageExtensions">
            <summary>
            Small helpers that make it easier to work with the <see cref="T:Rebus.Messages.Message"/> class
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.HasReturnAddress(Rebus.Messages.Message)">
            <summary>
            Gets whether the message's <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to something
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetReturnAddressFromTransport(Rebus.Messages.Message,Rebus.Transport.ITransport)">
            <summary>
            Uses the transport's input queue address as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> on the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.Message,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.TransportMessage,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.Message)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.Message)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.Message)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.TransportMessage)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.Clone(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a cloned instance of the transport message
            </summary>
        </member>
        <member name="T:Rebus.Compression.DataCompressionMode">
            <summary>
            Enumerates strategies for when the data bus storage decorator GZIps the data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Always">
            <summary>
            Always compresses data. Please note that this requires that data can be kept in memory as this
            is required by the streaming APIs used when compressing data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Explicit">
            <summary>
            Compresses data when the <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> key is detected among the metadata
            of the save data and the value is "gzip"
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipConfigurationExtensions">
            <summary>
            Configuration extensions for enabling compression
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes">
            <summary>
            Default threshold for the body size for compression to kick in
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)">
            <summary>
            Enables compression of outgoing messages if the size exceeds the specified number of bytes
            (defaults to <see cref="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes"/>)
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.UseCompression(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.Compression.DataCompressionMode)">
            <summary>
            Enables GZIP of the saved data bus data. Set <paramref name="dataCompressionMode"/> to control when data is gzipped - if <see cref="F:Rebus.Compression.DataCompressionMode.Always"/>
            is selected the data will always be GZIPped, whereas selecting <see cref="F:Rebus.Compression.DataCompressionMode.Explicit"/> makes the data be GZIPped
            only when <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> = "gzip" is detected among the metadata for the stored data.
            Please note that GZIPping the data requires that it can be fully contained in memory because the underlying streaming APIs do not support lazy-reading a
            GZIP stream.
            </summary>
        </member>
        <member name="T:Rebus.Compression.Zipper">
            <summary>
            Zipper that holds the zipping logic
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Zip(System.Byte[])">
            <summary>
            Zips the byte array
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Unzip(System.Byte[])">
            <summary>
            Unzips the byte array
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZippingDataBusStorageDecorator">
            <summary>
            Decorator for <see cref="T:Rebus.DataBus.IDataBusStorage"/> that GZIP-compresses data when it is streamed in/out
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.#ctor(Rebus.DataBus.IDataBusStorage,Rebus.Compression.DataCompressionMode)">
            <summary>
            Creates the decorator, wrapping the given <paramref name="innerDataBusStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="T:Rebus.Config.Configure">
            <summary>
            Configuration entry point - call the static <see cref="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)"/> method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> 
            (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)">
            <summary>
            Call this method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one 
            that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="T:Rebus.Config.OneWayClientBackdoor">
            <summary>
            Helper that gives a backdoor to the configuration <see cref="T:Rebus.Config.Options"/>, allowing for one-way client settings
            to be set.
            </summary>
        </member>
        <member name="M:Rebus.Config.OneWayClientBackdoor.ConfigureOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Uses the given <see cref="T:Rebus.Config.StandardConfigurer`1"/> of <see cref="T:Rebus.Transport.ITransport"/> to set the number of workers
            to zero (effectively disabling message processing) and installs a decorator of <see cref="T:Rebus.Bus.IBus"/> that prevents
            further modification of the number of workers (thus preventing accidentally starting workers when there's no input queue).
            </summary>
        </member>
        <member name="T:Rebus.Config.Options">
            <summary>
            Contains additional options for configuring Rebus internals
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultNumberOfWorkers">
            <summary>
            This is the default number of workers that will be started, unless <see cref="P:Rebus.Config.Options.NumberOfWorkers"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultMaxParallelism">
            <summary>
            This is the default number of concurrent asynchrounous operations allowed, unless <see cref="P:Rebus.Config.Options.MaxParallelism"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultWorkerShutdownTimeout">
            <summary>
            This is the default timeout for workers to finish running active handlers, unless <see cref="P:Rebus.Config.Options.WorkerShutdownTimeout" /> is set to something else.
            </summary>
            <value>1 minute per default.</value>
        </member>
        <member name="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval">
            <summary>
            This is the default due timeouts poll interval which will be used unless overridde by <see cref="P:Rebus.Config.Options.DueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.Options.#ctor">
            <summary>
            Constructs the options with the default settings
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.NumberOfWorkers">
            <summary>
            Configures the number of workers. If thread-based workers are used, this is the number of threads that will be created.
            This number should be less than or equal to <see cref="P:Rebus.Config.Options.MaxParallelism"/>.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.MaxParallelism">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.ExternalTimeoutManagerAddressOrNull">
            <summary>
            Gets/sets the address to use if an external timeout manager is to be used
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.DueTimeoutsPollInterval">
            <summary>
            Gets/sets the poll interval when checking for due timeouts
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.WorkerShutdownTimeout">
            <summary>
            Gets/sets the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="T:Rebus.Config.OptionsConfigurer">
            <summary>
            Allows for configuring additional options
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetNumberOfWorkers(System.Int32)">
            <summary>
            Configures the number of workers to start competing over the input queue
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetMaxParallelism(System.Int32)">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetWorkerShutdownTimeout(System.TimeSpan)">
            <summary>
            Configures the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetDueTimeoutsPollInteval(System.TimeSpan)">
            <summary>
            Configures the interval between polling the endpoint's configured <see cref="T:Rebus.Timeouts.ITimeoutManager"/> for due timeouts.
            Defaults to <see cref="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolver of the given primary implementation of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Has``1">
            <summary>
            Gets whether a primary implementation resolver has been registered for the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given decorator of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.LogPipeline(System.Boolean)">
            <summary>
            Outputs the layout of the send and receive pipelines to the log
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusConfigurer">
            <summary>
            Basic skeleton of the fluent configuration builder. Contains a method for each aspect that can be configured
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Logging(System.Action{Rebus.Config.RebusLoggingConfigurer})">
            <summary>
            Configures how Rebus logs stuff that happens
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})">
            <summary>
            Configures how Rebus sends/receives messages by allowing for choosing which implementation of <see cref="T:Rebus.Transport.ITransport"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Routing(System.Action{Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter}})">
            <summary>
            Configures how Rebus routes messages by allowing for choosing which implementation of <see cref="T:Rebus.Routing.IRouter"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Sagas(System.Action{Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage}})">
            <summary>
            Configures how Rebus persists saga data by allowing for choosing which implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Subscriptions(System.Action{Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage}})">
            <summary>
            Configures how Rebus persists subscriptions by allowing for choosing which implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Serialization(System.Action{Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer}})">
            <summary>
            Configures how Rebus serializes messages by allowing for choosing which implementation of <see cref="T:Rebus.Serialization.ISerializer"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Timeouts(System.Action{Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager}})">
            <summary>
            Configures how Rebus defers messages to the future by allowing for choosing which implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Options(System.Action{Rebus.Config.OptionsConfigurer})">
            <summary>
            Configures additional options about how Rebus works
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Start">
            <summary>
            Finishes the setup of the bus, using default implementations for the options that have not explicitly been set.
            The only requirement, is that you must call <see cref="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})"/> and select which transport to use - everything
            else can run with a default option. It should be noted though, that several of the defaults (e.g. in-mem persistence
            options for saga storage, subscriptions, and timeouts) are not meant for production use, and should probably be
            replaced by something that is actually persistent.
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusLoggingConfigurer">
            <summary>
            Configurer that is used to configure logging. This configurer is cheating a little bit because it will actually modify a global logger which will
            be used throughout all Rebus instances. This mechanism might change in the future
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Console(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to stdout, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.ColoredConsole(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to with different colors depending on the log level, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Trace">
            <summary>
            Configures Rebus to log its stuff to <see cref="T:System.Diagnostics.Trace"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.None">
            <summary>
            Disables logging alltogether
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Use(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Configures this Rebus instance to use the specified logger factory
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="T:Rebus.Config.StandardConfigurer`1">
            <summary>
            Configurer that can have extension methods attached to it for helping with registering an implementation or a decorator
            for the <typeparamref name="TService"/> service.
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.GetConfigurerFrom(Rebus.Config.OptionsConfigurer)">
            <summary>
            Gets a standard configurer from the given options configurer. Can be used to provide
            extensions to <see cref="T:Rebus.Config.OptionsConfigurer"/> that return a standard configurer that can then
            be used to build further
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Register(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Decorate(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.OtherService``1">
            <summary>
            Gets a typed configurer for another service. Can be useful if e.g. a configuration extension for a <see cref="T:Rebus.Transport.ITransport"/>
            wants to replace the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> because it is capable of using the transport layer to do pub/sub
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusAttachment">
            <summary>
            Model that represents a data bus attachment. Only the <see cref="P:Rebus.DataBus.DataBusAttachment.Id"/> is significant, as all the
            other pieces of information are not required in order to retrieve the attachment from the database.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.#ctor(System.String)">
            <summary>
            Creates a data bus attachment with the given ID
            </summary>
        </member>
        <member name="P:Rebus.DataBus.DataBusAttachment.Id">
            <summary>
            Gets the ID of the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata(System.String)">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusOptionsExtensions">
            <summary>
            Configuration extensions for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusOptionsExtensions.EnableDataBus(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables the data bus. 
            Please remember to select a data bus storage by calling an extension on the returned <see cref="T:Rebus.Config.StandardConfigurer`1"/>, e.g. like so:
            <code>
            Configure.With(..)
                .(...)
                .Options(o => o.EnableDataBus().StoreInSqlServer(....))
                .Start();
            </code>
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions">
            <summary>
            Provides extensions methods for configuring the file system storage for the data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions.StoreInFileSystem(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String)">
            <summary>
            Configures the data bus to store data in the file system
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that stores data in the file system. Could be a directory on a network share.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Initialize">
            <summary>
            Initializes the file system data storage by ensuring that the configured data directory path exists and that it is writable
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given strea under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Read(System.String)">
            <summary>
            Reads the data with the given ID and returns it as a stream
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBus">
            <summary>
            API for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.CreateAttachment(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates an attachment from the given source stream, optionally providing some extra metadata to be stored along with the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the currently configured data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.GetMetadata(System.String)">
            <summary>
            Uses the currently configured data bus to retrieve the metadata for the attachment with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBusStorage">
            <summary>
            Abstraction over the data bus storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataBusExtensions">
            <summary>
            Configuration extensions for the in-mem data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)">
            <summary>
            Configures the data bus to store data in memory. This is probably only useful for test scenarios, as the
            passed-in <paramref name="inMemDataStore"/> needs to be shared among endpoints on the data bus.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataStore">
            <summary>
            In-mem implementation of a data store that can be shared among buses that use the in-mem data bus.
            A shared instance of this class should be passed to all endpoints when calling <see cref="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)"/>
            </summary>
        </member>
        <member name="P:Rebus.DataBus.InMem.InMemDataStore.SizeBytes">
            <summary>
            Gets the total size in bytes 
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Save(System.String,System.Byte[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the given bytes under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Load(System.String)">
            <summary>
            Loads the bytes with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.AddMetadata(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Adds the metadata from the <paramref name="metadata"/> dictionary to the blob with the given <paramref name="id"/>
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.LoadMetadata(System.String)">
            <summary>
            Loads the metadata for the data with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="T:Rebus.DataBus.MetadataKeys">
            <summary>
            Contains keys of standard metadata which is always available on data stored with the data bus
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.Length">
            <summary>
            Metadata key of the length in bytes of the stored data
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.SaveTime">
            <summary>
            Metadata key of the ISO8601-encoded time of when the data was stored
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ReadTime">
            <summary>
            Metadata key of the ISO8601-encoding time of when the data was last read
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentEncoding">
            <summary>
            Optional header that might contain an encoding of the contents, e.g."gzip" for gzipped data.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.AesEncryptor">
            <summary>
            Helps with encrypting/decripting byte arrays, using the <see cref="T:System.Security.Cryptography.Aes"/> algorithm
            </summary>
        </member>
        <member name="P:Rebus.Encryption.AesEncryptor.ContentEncryptionValue">
            <summary>
            Returns "rijndael" string
            </summary>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.#ctor(System.String)">
            <summary>
            Creates the encrptor with the specified key - the key must be a valid, base64-encoded key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given array of bytes, using the configured key. Returns an <see cref="T:Rebus.Encryption.EncryptedData"/> containing the encrypted
            bytes and the generated salt.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.AesEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the given <see cref="T:Rebus.Encryption.EncryptedData"/> using the configured key.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.DecryptMessagesIncomingStep">
            <summary>
            Incoming message step that checks for the prensence of the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header, decrypting
            the message body if it is present.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Descrypts the incoming <see cref="T:Rebus.Messages.TransportMessage"/> if it has the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptedData">
            <summary>
            Represents a chunk of encrypted data along with the salt (a.k.a. "Initialization Vector"/"IV") that was used to encrypt it.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptedData.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructs an instance from the given bytes and iv.
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Iv">
            <summary>
            Gets the salt (a.k.a. "Initialization Vector"/"IV") from this encrypted data instance
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Bytes">
            <summary>
            Gets the raw data from this encrypted data instance
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionConfigurationExtensions">
            <summary>
            Configuration extensions for enabling encrypted message bodies
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableEncryption(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages. 
            Uses the default "Rijndael" algorithm which is 256 bit AES encryption.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableCustomEncryption(Rebus.Config.OptionsConfigurer)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages using custom encryption provider.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            Custom encrypotion providers are configured by building on the returned configurer, e.g. like so:
            <code>
            Configure.With(...)
                .(...)
                .Options(o => {
                    o.EnableCustomEncryption()
                        .Use***();
                })
                .Start();
            </code>
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionHeaders">
            <summary>
            Special headers that are used when the message contents are encrypted
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption">
            <summary>
            Optional header element that specifies an encryption algorithm that the contents have been encrypted with
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentInitializationVector">
            <summary>
            When the contents have been encrypted, this header has the IV
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.DisableEncryptionHeader">
            <summary>
            Special header that can be added to a message in order to disable encryption for that particular message
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptMessagesOutgoingStep">
            <summary>
            Outgoing pipeline step that encrypts the contents of the outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Encrypts the outgoing <see cref="T:Rebus.Messages.TransportMessage"/> and adds appropriate headers
            </summary>
        </member>
        <member name="T:Rebus.Encryption.IEncryptor">
            <summary>
            Interface to provide encryption/decryption custom implementation
            </summary>
        </member>
        <member name="P:Rebus.Encryption.IEncryptor.ContentEncryptionValue">
            <summary>
            Header name that will be added to an encrypted message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the encrypted data
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given bytes and returns the encrypted data alond with the salt in the returned <see cref="T:Rebus.Encryption.EncryptedData"/>
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.ConcurrencyException">
            <summary>
            Special exception that signals that some kind of optimistic lock has been violated, and work must most likely be aborted &amp; retried
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.FailFastException">
            <summary>
            Fail-fast exception bypasses the retry logic and goes to the error queue directly
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.FailFastException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.Ignorant">
            <summary>
            Helps keeping track of errors that we want to ignore for a while before acknowledging them
            </summary>
        </member>
        <member name="P:Rebus.Exceptions.Ignorant.SilencePeriods">
            <summary>
            Gets/sets the silence periods, i.e. the length of the intervals in which the ignorant will be silent
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.#ctor(System.Func{System.Exception,System.String})">
            <summary>
            Constructs the ignorant with the given mapping from an exception instance to the equality key that will be used to compare with previous exceptions.
            If no equality key mapper is given, it will default to using <see cref="P:System.Type.FullName"/> of the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.IsToBeIgnored(System.Exception)">
            <summary>
            Checks whether the given exception is to be ignored
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.Reset">
            <summary>
            Resets the silence period tracker - should be called after each success
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusApplicationException">
            <summary>
            Generic application exception to use when something bad happens that is pretty unexpected and should be taken seriously
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusConfigurationException">
            <summary>
            Generic configuration exception to use instead of ConfigurationErrorsException from System.Configuration
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusConfigurationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DateTimeExtensions">
            <summary>
            Defines a few nice extensions for making working with <see cref="T:System.DateTimeOffset"/> more nice
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ElapsedUntilNow(System.DateTimeOffset)">
            <summary>
            Gets the time from this instant until now (as returned by <see cref="P:Rebus.Time.RebusTime.Now"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToIso8601DateTimeOffset(System.DateTimeOffset)">
            <summary>
            Serializes this instant with the "O" format, i.e. ISO8601-compliant
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToDateTimeOffset(System.String)">
            <summary>
            Parses an ISO8601-compliant string into a proper <see cref="T:System.DateTimeOffset"/>
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DictionaryExtensions">
            <summary>
            Provides some nifty extensions to <see cref="T:System.Collections.Generic.Dictionary`2"/> and <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.MergedWith``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a new dictionary that contains all key-value pairs from both dictionaries. If the same key is present the value from <paramref name="otherDictionary"/> takes precedence
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.Clone(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Returns a new dictionary with the same key-value pairs as the target
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValue(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, throwing a MUCH nicer <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValueOrNull(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, returning null if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})">
            <summary>
            Provides a function similar to <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>, only
            on <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAddAsync``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Provides a function similar to <see cref="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})"/>, only where the factory function can be async
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.ToConcurrentDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Maps the given sequence of items to key-value pairs, returning them in a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrThrow``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrNull``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="T:Rebus.Extensions.EnumerableExtensions">
            <summary>
            Nifty extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/> 
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/>, checking equality with the given <paramref name="equalityComparer"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Iterates the sequence, calling the given <paramref name="itemAction"/> for each item
            </summary>
        </member>
        <member name="T:Rebus.Extensions.TypeExtensions">
            <summary>
            Provides extensions of <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetBaseTypes(System.Type)">
            <summary>
            Gets the type's base types (i.e. the <see cref="T:System.Type"/> for each implemented interface and for each class inherited from, all the way up to <see cref="T:System.Object"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetSimpleAssemblyQualifiedName(System.Type)">
            <summary>
            Gets the assembly-qualified name of the type, without any version info etc.
            E.g. "System.String, mscorlib"
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages">
            <summary>
            Base message handler interface. Don't implement this one directly, it would give you nothing
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages`1">
            <summary>
            Message handler interface. Implement this in order to get to handle messages of a specific type
            </summary>
        </member>
        <member name="M:Rebus.Handlers.IHandleMessages`1.Handle(`0)">
            <summary>
            This method will be invoked with a message of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Handlers.InternalHandlersContributor">
            <summary>
            Decoration of <see cref="T:Rebus.Activation.IHandlerActivator"/> that adds a few special handlers when an incoming message can be recognized
            as a special Rebus message
            </summary>
        </member>
        <member name="M:Rebus.Handlers.InternalHandlersContributor.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Gets Rebus' own internal handlers (if any) for the given message type
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> that allows for specifying additional handler types
            whose order to fix
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1">
            <summary>
            Specifies the handler that will be put next in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            again to specify the next handler
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions">
            <summary>
            Configuration extensions for setting up an order of handlers that must be respected when
            two or more of the handlers are present in the same handler pipeline
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)">
            <summary>
            Initiates the configuration of the handler ordering - call <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> in
            order to specify the handler that will be put first in the pipeline if it is present
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingStep">
            <summary>
            Incoming message step that can reorder handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.#ctor(Rebus.Handlers.Reordering.ReorderingConfiguration)">
            <summary>
            Constructs the step with the given configuration
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Reorders the handler invokers if necessary
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.ReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)"/> that can be used as a
            fluent syntax to specify the desired order of the handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1">
            <summary>
            Specifies the handler that will be put first in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            any number of times to specify the next handler
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.GetIndex(System.Object)">
            <summary>
            Gets the sorting index for the given handler
            </summary>
        </member>
        <member name="T:Rebus.Injection.Injectionist">
            <summary>
            Dependency injectionist that can be used for configuring a system of injected service implementations, possibly with decorators,
            with caching of instances so that the same instance of each class is used throughout the tree. Should probably not be used for
            anything at runtime, is only meant to be used in configuration scenarios.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Get``1">
            <summary>
            Starts a new resolution context, resolving an instance of the given <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="E:Rebus.Injection.Injectionist.ResolveRequested">
            <summary>
            Events that is raised when the resolution of a top-level instance is requested
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a factory method that can provide an instance of <typeparamref name="TService"/>. Optionally,
            the supplied <paramref name="description"/> will be used to report more comprehensible errors in case of
            conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a decorator factory method that can provide an instance of <typeparamref name="TService"/> 
            (i.e. the resolver is expected to call <see cref="M:Rebus.Injection.IResolutionContext.Get``1"/> where TService
            is <typeparamref name="TService"/>. Optionally, the supplied <paramref name="description"/> will be used 
            to report more comprehensible errors in case of conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Has``1(System.Boolean)">
            <summary>
            Returns whether there exists a registration for the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="T:Rebus.Injection.IResolutionContext">
            <summary>
            Represents the context of resolving one root service and can be used throughout the tree to fetch something to be injected
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Get``1">
            <summary>
            Gets an instance of the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="P:Rebus.Injection.IResolutionContext.TrackedInstances">
            <summary>
            Gets all instances resolved within this resolution context at this time.
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Has``1(System.Boolean)">
            <summary>
            Gets whether there exists a primary registration for the <typeparamref name="TService"/> type
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionException">
            <summary>
            Exceptions that is thrown when something goes wrong while working with the injectionist
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionResult`1">
            <summary>
            Contains a built object instance along with all the objects that were used to build the instance
            </summary>
        </member>
        <member name="P:Rebus.Injection.ResolutionResult`1.Instance">
            <summary>
            Gets the instance that was built
            </summary>
        </member>
        <member name="P:Rebus.Injection.ResolutionResult`1.TrackedInstances">
            <summary>
            Gets all object instances that were used to build <see cref="P:Rebus.Injection.ResolutionResult`1.Instance"/>, including the instance itself
            </summary>
        </member>
        <member name="T:Rebus.Logging.AbstractRebusLoggerFactory">
            <summary>
            If you intend to implement your own logging, you probably want to derive from this class and implement <seealso cref="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)"/>
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger``1">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.RenderString(System.String,System.Object[])">
            <summary>
            Renders the <paramref name="message"/> string by replacing placeholders on the form <code>{whatever}</code> with the
            string representation of each object from <paramref name="objs"/>. Note that the actual content of the placeholders
            is ignored - i.e. it doesn't matter whether it says <code>{0}</code>, <code>{name}</code>, or <code>{whatvgejigoejigoejigoe}</code>
            - values are interpolated based on their order regardless of the name of the placeholder.
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.FormatObject(System.Object,System.String)">
            <summary>
            Formatter function that is invoked for each object value to be rendered into a string while interpolating log lines
            </summary>
        </member>
        <member name="T:Rebus.Logging.ColorSetting">
            <summary>
            Represents a console color setting consisting of a foreground and a background color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.ForegroundColor">
            <summary>
            Gets the foreground color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.BackgroundColor">
            <summary>
            Gets the background color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Foreground(System.ConsoleColor)">
            <summary>
            Sets the foreground color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Background(System.ConsoleColor)">
            <summary>
            Sets the background color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Enter">
            <summary>
            Sets the current console colors to those specified in this <see cref="T:Rebus.Logging.ColorSetting"/>,
            restoring them to the previous colors when disposing
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory">
            <summary>
            Logger factory that logs stuff to the console
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory.LogStatement">
            <summary>
            One single log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Level">
            <summary>
            The level of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Text">
            <summary>
            The text (possibly inclusing formatting placeholders) of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Args">
            <summary>
            The values to use for string interpolation
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Type">
            <summary>
            The type to which this particular logger belongs
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.#ctor(System.Boolean)">
            <summary>
            Constructs the logger factory
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Colors">
            <summary>
            Gets or sets the colors to use when logging
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.MinLevel">
            <summary>
            Gets or sets the minimum logging level to output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Filters">
            <summary>
            Gets the list of filters that each log statement will be passed through in order to evaluate whether
            the given log statement should be output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.ShowTimestamps">
            <summary>
            Gets/sets whether timestamps should be shown when logging
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a logger for logging stuff from within the specified type
            </summary>
        </member>
        <member name="T:Rebus.Logging.ILog">
            <summary>
            Interface of a Rebus logger
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Debug(System.String,System.Object[])">
            <summary>
            Writes the specified message with the DEBUG level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Info(System.String,System.Object[])">
            <summary>
            Writes the specified message with the INFO level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="T:Rebus.Logging.IRebusLoggerFactory">
            <summary>
            Basic interface of a Rebus logger factory. You can make a tiny shortcut by deriving from <see cref="T:Rebus.Logging.AbstractRebusLoggerFactory"/> if you intend to implement this interface
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetLogger``1">
            <summary>
            Gets a logger for the type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:Rebus.Logging.LoggingColors">
            <summary>
            Represents a set of colors to be used by the <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> when running
            in colored mode
            </summary>
        </member>
        <member name="M:Rebus.Logging.LoggingColors.#ctor">
            <summary>
            Constructs the default set of logging colors, which if gray, green, yellow, and red foreground for log
            levels debug, info, warn, and error respectively.
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Debug">
            <summary>
            Gets/sets the color to use when printing DEBUG log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Info">
            <summary>
            Gets/sets the color to use when printing INFO log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Warn">
            <summary>
            Gets/sets the color to use when printing WARN log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Error">
            <summary>
            Gets/sets the color to use when printing ERROR log statements
            </summary>
        </member>
        <member name="T:Rebus.Logging.LogLevel">
            <summary>
            Enumeration of the log levels available with Rebus loggers. As a general rule of thumb, levels WARN
            and ERROR should, as a minimum, ALWAYS be logged to a local file or another persistent means.
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Debug">
            <summary>
            Log statement of very low importance which is most likely only relevant in extreme debugging scenarios
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Info">
            <summary>
            Log statement of low importance to unwatched running systems which however can be very relevant when testing and debugging
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Warn">
            <summary>
            Log statement of fairly high importance - always contains relevant information on somewhing that may be a sign that something is wrong
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Error">
            <summary>
            Log statement of the highest importance - always contains relevant information on something that has gone wrong
            </summary>
        </member>
        <member name="T:Rebus.Logging.NullLoggerFactory">
            <summary>
            This is the /dev/null of loggers...
            </summary>
        </member>
        <member name="M:Rebus.Logging.NullLoggerFactory.GetLogger(System.Type)">
            <summary>
            Returns a <see cref="T:Rebus.Logging.NullLoggerFactory.NullLogger"/> which is the /dev/null of logging...
            </summary>
        </member>
        <member name="T:Rebus.Logging.TraceLoggerFactory">
            <summary>
            Logger factory that writes log statements using the <see cref="T:System.Diagnostics.Trace"/> API
            </summary>
        </member>
        <member name="M:Rebus.Logging.TraceLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.TraceLoggerFactory.TraceLogger"/>
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.SubscribeRequest">
            <summary>
            Control message that can be used to establish a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to enlist for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.Topic">
            <summary>
            Specifis the topic for which the subscriber wishes to subscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.UnsubscribeRequest">
            <summary>
            Control message that can be used to end a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to remove for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.Topic">
            <summary>
            Specifis the topic from which the subscriber wishes to unsubscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.HeaderAttribute">
            <summary>
            Header attribute that can be used to automatically add some specific header to all outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Key">
            <summary>
            Gets the key of the header
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Value">
            <summary>
            Gets the value of the header
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates the header attribute with the given key and value
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String)">
            <summary>
            Creates the header attribute with the given key and an empty value
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers">
            <summary>
            Contains keys of headers known &amp; used by Rebus
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.MessageId">
            <summary>
            Id of the message. Either set the ID explicitly when sending a message, or Rebus will assign one to the message.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Type">
            <summary>
            .NET type (if possible) of the sent message 
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationId">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get the correlation ID (or the message ID
            if there's no correlation ID) of the handled message copied to it. When a message is initially sent, its correlation ID
            will be its own message ID.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.InReplyTo">
            <summary>
            Contains the <see cref="F:Rebus.Messages.Headers.MessageId"/> from the handled message when replying from a handler
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationSequence">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get a correlation sequence number of the handled message 
            incremented by 1 copied to it. When a message is initially sent, its correlation sequence number is 0. The sequence number
            can be used to deduce a strict ordering of correlated messages, even in the face of clock skew among servers
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ReturnAddress">
            <summary>
            The return address of the message, i.e. the address that repliers must reply to.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.RoutingSlipItinerary">
            <summary>
            A ;-separated list of addresses that the routing slip must visit
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.RoutingSlipTravelogue">
            <summary>
            A ;-separated list of addresses that the routing slip has visited
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentType">
            <summary>
            Describes the contents of the message with a type and an encoding
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentEncoding">
            <summary>
            Optional header element that specifies an encoding that the content is encoded with, e.g. gzip
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ErrorDetails">
            <summary>
            Details that can be attached to a message that is forwarded after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SourceQueue">
            <summary>
            Source queue of a message the has bee forwarded to an error queue after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredUntil">
            <summary>
            Indicates that the message must not be consumed right away, delivery should be delayed until the specified time
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredRecipient">
            <summary>
            Indicates to which input queue the deferred message must be delivered back to
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.TimeToBeReceived">
            <summary>
            Indicates a time span (as a string, on the form hh:MM:ss) after which the queueing system can safely delete the message and thus never deliver it
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Express">
            <summary>
            Header that indicates that the queueing system can trade reliability for performance in order to deliver this message as fast as possible
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SentTime">
            <summary>
            Headers with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message was sent.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Intent">
            <summary>
            Header that indicates whether this message was sent or published
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers.IntentOptions">
            <summary>
            Contains the possible values for the <see cref="F:Rebus.Messages.Headers.Intent"/> header
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PointToPoint">
            <summary>
            This value indicates that the message was sent to one specific recipient, i.e. either by sending or replying
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe">
            <summary>
            This value indicates that the message was published to zero or more recipients, i.e. it might not actually be received by anyone.
            When auditing is enabled, a copy is always stored of published messages, regardless of the number of recipients.
            </summary>
        </member>
        <member name="T:Rebus.Messages.Message">
            <summary>
            Logical message wrapper that has a set of headers and a .NET object
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Object)">
            <summary>
            Constructs the message with the specified headers, wrapping the given .NET object as the message body
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Body">
            <summary>
            Gets the wrapped body object of this message
            </summary>
        </member>
        <member name="T:Rebus.Messages.OriginalTransportMessage">
            <summary>
            Wraps the originally received transport message while processing the message because the original 
            instance might be replaced during the processing (e.g. when its body is changed during decompression/decryption etc.)
            This instance must not be changed
            </summary>
        </member>
        <member name="P:Rebus.Messages.OriginalTransportMessage.TransportMessage">
            <summary>
            Gets the originally received transport message
            </summary>
        </member>
        <member name="M:Rebus.Messages.OriginalTransportMessage.#ctor(Rebus.Messages.TransportMessage)">
            <summary>
            Creates the wrapper
            </summary>
        </member>
        <member name="T:Rebus.Messages.TransportMessage">
            <summary>
            Transport message wrapper that has a set of headers and a stream of raw data to be sent/received
            </summary>
        </member>
        <member name="M:Rebus.Messages.TransportMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Constructs the transport message with the given headers, wrapping the given body payload
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Body">
            <summary>
            Gets the wrapped body data of this message
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that writes saga data snapshots as JSON text to a directory in the file system
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage which will write saga data snapshots to files using file names on the form "ID-REVISION.json"
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Initialize">
            <summary>
            Initializes the file system-based saga snapshot storage by ensuring that the snapshot directory exists and
            making sure that it's writable
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions">
            <summary>
            Configuration extensions for the <see cref="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String)">
            <summary>
            Configures Rebus to use JSON files to store snapshots of saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that uses the file system to store data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the saga storage using the given <paramref name="basePath"/> 
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data instance from the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data instance into the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given saga data instance in the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Removes the saga data instance from the index file
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions">
            <summary>
            Configures extensions for using the filesystem to store sagas
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions.UseFilesystem(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String)">
            <summary>
            Configures Rebus to use the filesystem to store sagas. Please note that this way of storing saga data is not
            the most effective, and therefore it is probably best suited for testing and very simple and mild requirements
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that stores timeouts in the filesystem
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutManager.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the timeout manager, storing timeouts in the given <paramref name="basePath"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message to be retrieved later
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutManager.GetDueMessages">
            <summary>
            Gets all messages that are due at this instant
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemTimeoutStorageConfigurationExtensions">
            <summary>
            Configures the bus to use the filesystem to store timeouts
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemTimeoutStorageConfigurationExtensions.UseFileSystem(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String)">
            <summary>
            Configures the bus to use the filesystem to store timeouts
            </summary>
            <param name="configurer">the rebus configuration</param>
            <param name="basePath">the path to store timeouts under</param>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that stores subscriptions in a JSON file. Access to the file is synchronized within the process with a <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all subscribers of the given topic from the JSON file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber to the list of subscribers from the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber from the list of subscribers of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized (which it shouldn't be - that would probably cause some pretty nasty locking exceptions!)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.ReaderWriterLockSlim"/> that guards access to the file
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions">
            <summary>
            Configurations extensions for configuring Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String)">
            <summary>
            Configures Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that "persists" saga data in memory. Saga data is serialized/deserialized using Newtonsoft JSON.NET
            with some pretty robust settings, so inheritance and interfaces etc. can be used in the saga data.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data of the given type with a property of the specified name and the specified value
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Saves the given saga data, throwing an exception if the instance already exists
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the saga data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySagaStorageExtensions">
            <summary>
            Configuration extensions for in-mem saga storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage})">
            <summary>
            Configures Rebus to store sagas in memory. Please note that while this method can be used for production purposes
            (if you need a saga storage that is pretty fast), it is probably better to use a persistent storage (like SQL Server
            or another database), because the state of all sagas will be lost in case the endpoint is restarted.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriberStore">
            <summary>
            In-mem subscriber store that can be shared among multiple endpoints to emulate a shared subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.GetSubscribers(System.String)">
            <summary>
            Gets the subscribers for the current topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.AddSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber with the given <paramref name="subscriberAddress"/> to the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.RemoveSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber with the given <paramref name="subscriberAddress"/> from the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that "persists" subscriptions in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.#ctor">
            <summary>
            Creates the in-mem subscription storage as a decentralized subscription storage with its
            own private subscriber store
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.#ctor(Rebus.Persistence.InMem.InMemorySubscriberStore)">
            <summary>
            Creates the in-mem subscription storage as a centralized subscription storage, using the given
            <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> to share subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemorySubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions">
            <summary>
            Configuration extensions for in-mem subscriptionstorage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},Rebus.Persistence.InMem.InMemorySubscriberStore)">
            <summary>
            Configures Rebus to store subscriptions in memory. The subscription storage is assumed to be CENTRALIZED
            with this overload because a <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> is passed in.  PLEASE NOTE that this 
            is probably not useful for any other scenario  than TESTING because usually you want subscriptions to be PERSISTENT.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage})">
            <summary>
            Configures Rebus to store subscriptions in memory. The subscription storage is assumed to be DECENTRALIZED
            with this overload because NO <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> is passed in and subscriptions are therefore private
            for this endpoint.  PLEASE NOTE that this  is probably not useful for any other scenario  than TESTING because usually you want 
            subscriptions to be PERSISTENT.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that "persists" timeouts in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage">
            <summary>
            Represents a message whose delivery has been deferred into the future
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.DueTime">
            <summary>
            Gets the time of when delivery of this message is due
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.Headers">
            <summary>
            Gets the message's headers
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.Body">
            <summary>
            Gets the message's body
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetEnumerator">
            <summary>
            Gets an enumerator that allows for iterating through all stored deferred messages
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManagerExtensions">
            <summary>
            Configuration extensions for in-mem timeout manager
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManagerExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager})">
            <summary>
            Configures Rebus to store timeouts in memory. Please note that this is probably not really suitable for production usage,
            as deferred messages will be lost in case the endpoint is restarted. Therefore, the in-mem timeout manager is probably
            mostly suited best to be used in automated tests.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.DefaultPipeline">
            <summary>
            Default pipeline implementation that can be built with a fluent syntax by calling <see cref="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)"/> and <see cref="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)"/> respectively,
            in the order that the steps must be invoked in.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.#ctor(System.Collections.Generic.IEnumerable{Rebus.Pipeline.IOutgoingStep},System.Collections.Generic.IEnumerable{Rebus.Pipeline.IIncomingStep})">
            <summary>
            Creates the pipeline, possibly initializing it from the given <paramref name="initialOutgoingSteps"/> and/or <paramref name="initialIncomingSteps"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.SendPipeline">
            <summary>
            Gets the send pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)">
            <summary>
            Adds a new incoming step to the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)">
            <summary>
            Adds a new outgoing step to the send pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IIncomingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each incoming message to be handled.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the incoming message :)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IMessageContext">
            <summary>
            Representation of the current "message context", which is a convenience wrapper that gives access to the current <see cref="T:Rebus.Transport.ITransactionContext"/>
            (which is the outermost context, the one that spans the entire queue receive transaction) and the current
            <see cref="P:Rebus.Pipeline.IMessageContext.IncomingStepContext"/> (which is actually contained in the transaction context).
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Headers">
            <summary>
            Gets the headers dictionary of the incoming message (same as accessing the Headers of the context's transport message,
            or the logical message if the message has been properly deserialized)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IncomingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing incoming messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IncomingStepContext.#ctor(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.TransportMessage"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.ActionPipelineInvoker">
            <summary>
            Action-based pipeline invoker that recursively composes actions to invoke the pipelines
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.CompiledPipelineInvoker">
            <summary>
            Expression-based pipeline invoker that builds a compiled function to invoke the pipeline(s)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.CompiledPipelineInvoker.GenerateExpression``2(System.Collections.Generic.IReadOnlyCollection{``1},System.String,System.Int32)">
            <summary>
            Recursively builds and expression that invokes the pipeline, FUN STYLE BABY!
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.DefaultPipelineInvoker">
            <summary>
            give me a pipeline and I'll invoke it
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvoker.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew">
            <summary>
            give me a pipeline and I'll invoke it
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew.Invoke(Rebus.Pipeline.IncomingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew.Invoke(Rebus.Pipeline.OutgoingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IOutgoingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each outgoing message to be sent.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipeline">
            <summary>
            Models a pipeline of steps that will be executed for each sent/received message respectively
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.SendPipeline">
            <summary>
            Gets the send pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> implementations that will be executed for each outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> implementations that will be executed for each incoming message
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipelineInvoker">
            <summary>
            The invoker is capable of invoking an ordered pipeline of steps
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext)">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IStep">
            <summary>
            General step interface - allows for treating incoming/outgoing pipeline steps equally in some regards, even though they're different
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.MessageContext">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IMessageContext"/> that provides the static gateway <see cref="P:Rebus.Pipeline.MessageContext.Current"/> property to get
            the current message context.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Headers">
            <summary>
            Gets the headers dictionary of the incoming message (same as accessing the Headers of the context's transport message,
            or the logical message if the message has been properly deserialized)
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Current">
            <summary>
            Gets the current message context from the current <see cref="T:Rebus.Transport.AmbientTransactionContext"/> (accessed by
            <see cref="P:Rebus.Transport.AmbientTransactionContext.Current"/>), returning null if no transaction context was found
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.OutgoingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.OutgoingStepContext.#ctor(Rebus.Messages.Message,Rebus.Transport.ITransactionContext,Rebus.Pipeline.Send.DestinationAddresses)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.Message"/>, list of <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineAbsolutePosition">
            <summary>
            Indicates an absolute position in the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Front">
            <summary>
            Denotes the front of the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Back">
            <summary>
            Denotes the back of the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineCache">
            <summary>
            Cache that can be used as the outermost decorator in order to avoid contantly running any pipeline step injection logic
            that might be configured
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineMessageContextExtensions">
            <summary>
            Extensions for the message context 
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineMessageContextExtensions.AbortDispatch(Rebus.Pipeline.IMessageContext)">
            <summary>
            Aborts the current message processing pipeline by making the currently executing handler the last one.
            This means that any message handlers following the current one in the current pipeline will NOT be executed.
            If no errors occurred, the queue transaction will be committed as if everything is allright.
            This method can be used to ABORT message process to allow for a handler to FUNCTION AS A FILTER.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineRelativePosition">
            <summary>
            Indicates in which way a position is related to another step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.Before">
            <summary>
            Indicates that the step must be positioned before the other step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.After">
            <summary>
            Indicates that the step must be positioned after the other step
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepConcatenator">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can concatenate steps to either pipeline at the front or at the back
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the concatenator
            </summary>
            <param name="pipeline"></param>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified outgoing <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified receive <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.SendPipeline">
            <summary>
            Gets the send pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.ReceivePipeline">
            <summary>
            Gets the receive pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepInjector">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can inject one or more steps into either pipeline,
            positionint the injected steps relatively to another step by its type.
            Could probably be extended with more ways of detecting "the other step" than by its concrete type.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the step injector, wrapping the given <see cref="T:Rebus.Pipeline.IPipeline"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.SendPipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that makes up the outgoing pipeline, injecting any configured outgoing steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.ReceivePipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> that makes up the incoming pipeline, injecting any configured incoming steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IOutgoingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IIncomingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepRemover">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can remove steps based on a predicate
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the pipeline step remover, wrapping the given pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.SendPipeline">
            <summary>
            Gets the outgoing steps from the wrapped pipeline, unless those where one of the registered outgoing step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.ReceivePipeline">
            <summary>
            Gets the incoming steps from the wrapped pipeline, unless those where one of the registered incoming step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveIncomingStep(System.Func{Rebus.Pipeline.IIncomingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching incoming steps to be removed from the pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveOutgoingStep(System.Func{Rebus.Pipeline.IOutgoingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching outgoing steps to be removed from the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.ActivateHandlersStep">
            <summary>
            Incoming message step that gets relevant handlers for the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.#ctor(Rebus.Activation.IHandlerActivator)">
            <summary>
            Constructs the step with the <see cref="T:Rebus.Activation.IHandlerActivator"/> to use to get the handler instances
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Looks up handlers for the incoming message and saves the handlers (without invoking them) to the context as a <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep">
            <summary>
            Incoming step that gets the current <see cref="T:Rebus.Messages.TransportMessage"/> from the context and deserializes its body,
            saving the result as a <see cref="T:Rebus.Messages.Message"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Deserializes the incoming message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.TransportMessage"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.Message"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DispatchIncomingMessageStep">
            <summary>
            Incoming step that gets a <see cref="T:System.Collections.Generic.List`1"/> where T is <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> from the context
            and invokes them in the order they're in.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.AbortDispatchContextKey">
            <summary>
            Keys of an <see cref="T:Rebus.Pipeline.IncomingStepContext"/> items that indicates that message dispatch must be stopped
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Processes the message
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandleDeferredMessagesStep">
            <summary>
            Incoming step that checks for the presence of the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header, using a
            <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to handle the deferral if necessary.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.#ctor(Rebus.Timeouts.ITimeoutManager,Rebus.Transport.ITransport,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the step, using the specified <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to defer relevant messages
            and the specified <see cref="T:Rebus.Transport.ITransport"/> to deliver messages when they're due.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Initialize">
            <summary>
            Initialized the step (starts the <see cref="F:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.DueMessagesSenderTaskName"/> background task if using the internal timeout manager)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks to see if the incoming message has the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header. If that is the case, the message is either stored for later delivery
            or forwarded to the configured external timeout manager. If not, the message will be passed on down the pipeline.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Dispose">
            <summary>
            Last-resort disposal of the due messages background task
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker">
            <summary>
            Wrapper of the handler that is ready to invoke
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.CanBeInitiatedBy(System.Type)">
            <summary>
            Gets whether a message of the given type is allowed to cause a new saga data instance to be created
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.HandlerInvoker.CurrentHandlerInvokerItemsKey">
            <summary>
            Key under which the handler invoker will stash itself in the <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            during the invocation of the wrapped handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke">
            <summary>
            Method to call in order to invoke this particular handler
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.HasSaga">
            <summary>
            Gets whether this invoker's handler is a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Saga">
            <summary>
            Gets this invoker's handler as a saga (throws if it's not a saga)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Adds to the invoker a piece of saga data that has been determined to be relevant for the invocation
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.GetSagaData">
            <summary>
            Gets from the invoker the piece of saga data that has been determined to be relevant for the invocation, returning null if no such saga data has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SkipInvocation">
            <summary>
            Marks this handler as one to skip, i.e. calling this method will make the invoker ignore the call to <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke"/>
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Handler">
            <summary>
            Gets the contained handler object (which is probably an implementation of <see cref="T:Rebus.Handlers.IHandleMessages"/>, but you should
            not depend on it!)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker`1">
            <summary>
            Derivation of the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> that has the message type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.#ctor(System.Func{System.Threading.Tasks.Task},System.Object,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler">
            <summary>
            Gets the contained handler object
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga">
            <summary>
            Gets whther the contained handler object has a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga">
            <summary>
            If <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga"/> returned true, the <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler"/> can be retrieved as a <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga"/> here
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke">
            <summary>
            Invokes the handler within this handler invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Sets a saga instance on the handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.GetSagaData">
            <summary>
            Gets the saga data (if any) that was previously set with <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)"/>. Returns null
            if none has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SkipInvocation">
            <summary>
            Marks this handler invoker to skip its invocation, causing it to do nothin when <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke"/> is called
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvokers">
            <summary>
            Represents a sequence of handler invokers
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.#ctor(Rebus.Messages.Message,System.Collections.Generic.IEnumerable{Rebus.Pipeline.Receive.HandlerInvoker})">
            <summary>
            Constructs the sequence
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvokers.Message">
            <summary>
            Gets the logical message that the accompanying handler invokers are working on
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.GetEnumerator">
            <summary>
            Gets all the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/>s that this <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/> contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandleRoutingSlipsStep">
            <summary>
            Pipeline step that forwards routing slips when needed
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleRoutingSlipsStep.#ctor(Rebus.Transport.ITransport,Rebus.Serialization.ISerializer)">
            <summary>
            Creates the step
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleRoutingSlipsStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out the routing slip forwarding logic
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignDateTimeOffsetHeader">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.SentTime"/> header of the outgoing message to <see cref="P:Rebus.Time.RebusTime.Now"/>
            (serializing it with the "O" format, i.e. its ISO 8601 representation)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDateTimeOffsetHeader.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.SentTime"/> header
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignDefaultHeadersStep">
            <summary>
            Outgoing step that sets default headers of the outgoing message.
            If the <see cref="F:Rebus.Messages.Headers.MessageId"/> header has not been set, it is set to a new GUID.
            If the bus is not a one-way client, the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to the address of the transport (unless the header has already been set to something else)
            The <see cref="F:Rebus.Messages.Headers.SentTime"/> header is set to <see cref="P:System.DateTimeOffset.Now"/>.
            If the <see cref="F:Rebus.Messages.Headers.Type"/> header has not been set, it is set to the simple assembly-qualified name of the send message type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDefaultHeadersStep.#ctor(Rebus.Transport.ITransport)">
            <summary>
            Constructs the step, getting the input queue address from the given <see cref="T:Rebus.Transport.ITransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDefaultHeadersStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the step and sets the default headers
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignGuidMessageIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.MessageId"/> header of the outgoing message, unless it has already been set.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignGuidMessageIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.MessageId"/>. The message ID is a new <see cref="T:System.Guid"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignReturnAddressStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the outgoing message to the input queue
            address (found with <see cref="P:Rebus.Transport.ITransport.Address"/>), unless the header has already been set to something else.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignReturnAddressStep.#ctor(Rebus.Transport.ITransport)">
            <summary>
            Constructs the step, getting the input queue address from the given <see cref="T:Rebus.Transport.ITransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignReturnAddressStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            If no return address has been added to the message, the sender's input queue address is automatically added as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/>
            header
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignTypeHeaderStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.Type"/> header of the outgoing message, unless it has already been set.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignTypeHeaderStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.Type"/> to the simple assembly-qualified type name of the sent object, unless
            the header has not already been added
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AutoHeadersOutgoingStep">
            <summary>
            Outgoing step that picks up <see cref="T:Rebus.Messages.HeaderAttribute"/> from the message type, automatically adding headers
            with <see cref="P:Rebus.Messages.HeaderAttribute.Key"/> set to <see cref="P:Rebus.Messages.HeaderAttribute.Value"/> if a header with such key has not already been added.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AutoHeadersOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out the auto-header logic
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.DestinationAddresses">
            <summary>
            Encapsulates a list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs the list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.GetEnumerator">
            <summary>
            Gets all the addresses that this <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> object contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.FlowCorrelationIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.CorrelationId"/> header of the outgoing message if it has not already been set.
            The value used is one of the following (in prioritized order):
            1) The correlation ID of the message currently being handled,
            2) The message ID of the message currently being handled,
            3) The message's own message ID
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.FlowCorrelationIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Flows the correlation ID like it should
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SendOutgoingMessageStep">
            <summary>
            Outgoing step that uses the current transport to send the <see cref="T:Rebus.Messages.TransportMessage"/>
            found in the context to the destination address specified by looking up
            <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> in the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step, using the specified transport to send the messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sends the outgoing message using the configured <see cref="T:Rebus.Transport.ITransport"/>, sending to the <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/>
            found in the <see cref="T:Rebus.Pipeline.OutgoingStepContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SerializeOutgoingMessageStep">
            <summary>
            Outgoing step that gets the current <see cref="T:Rebus.Messages.Message"/> from the context and serializes its body,
            saving the result as a <see cref="T:Rebus.Messages.TransportMessage"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Serializes the outgoing message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.Message"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.TransportMessage"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.ValidateOutgoingMessageStep">
            <summary>
            Outgoing message step that checks the consistency of the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.ValidateOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the step
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepContext">
            <summary>
            General step context model that encapsulates an object bag that can be used to pass data from step to step when executing a step pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.StepContext.StepContextKey">
            <summary>
            Key reserved for the step context when it is inserted into the current <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(``0)">
            <summary>
            Saves the given instance in the bag with a key derived from the (possibly explicitly specified) type <typeparamref name="T"/> (by calling <see cref="P:System.Type.FullName"/>).
            Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(System.String,``0)">
            <summary>
            Saves the given instance in the bag with the specified key. Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1">
            <summary>
            Loads the instance stored under the key that is stored under a key as determined by calling <see cref="P:System.Type.FullName"/> on the specified type <typeparamref name="T"/>.
            Returns null if none could be found.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1(System.String)">
            <summary>
            Loads the instance stored under the specified key. Returns null if none could be found.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepDocumentationAttribute">
            <summary>
            Documents the purpose of an <see cref="T:Rebus.Pipeline.IIncomingStep"/> or <see cref="T:Rebus.Pipeline.IOutgoingStep"/> which can then be used by tools to generate nice docs
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepDocumentationAttribute.#ctor(System.String)">
            <summary>
            Creates the attribute with the given documentation text. Will be included in the output
            when logging the message pipelines at startup, which is done by calling
            <code>.Options(o => o.LogPipeline(verbose: true|false))</code>
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.StepDocumentationAttribute.Text">
            <summary>
            Gets the documentation text
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfiler">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IPipeline"/> that wraps another <see cref="T:Rebus.Pipeline.IPipeline"/>
            and injects instances of a single step into the pipeline which can be used to measure time spent
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.#ctor(Rebus.Pipeline.IPipeline,Rebus.Profiling.PipelineStepProfilerStats)">
            <summary>
            Creates the profiler
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.SendPipeline">
            <summary>
            Gets the original send pipeline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.ReceivePipeline">
            <summary>
            Gets a pipeline with time-tracking steps interleaved
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfilerStats">
            <summary>
            Stats collector
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.GetAndResetStats">
            <summary>
            Gets the current stats and resets the collector
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.GetStats">
            <summary>
            Gets the current stats
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfilerStats.StepStat">
            <summary>
            Represents an aggregation of measurements
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.StepType">
            <summary>
            Type of step for which this particular statistic was collected
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.Elapsed">
            <summary>
            Time spent
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.Percentage">
            <summary>
            Gets the percentage of time spent in this particular step
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.StepStat.ToString">
            <summary>
            Gets a string representation of this stat on the form "type: elapsed"
            </summary>
        </member>
        <member name="T:Rebus.Retry.ErrorTracking.InMemErrorTracker">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IErrorTracker"/> that tracks errors in an in-mem dictionary
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.#ctor(System.Int32,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the in-mem error tracker with the configured number of delivery attempts as the MAX
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Initialize">
            <summary>
            Initializes the in-mem error tracker - starts a background task that periodically cleans up tracked errors that haven't had any activity for 10 minutes or more
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.RegisterError(System.String,System.Exception,System.Boolean)">
            <summary>
            Registers the given <paramref name="exception"/> under the supplied <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether too many errors have been tracked for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetShortErrorDescription(System.String)">
            <summary>
            Gets a short description of the tracked errors for the given <paramref name="messageId"/> on the form
            "n unhandled exceptions"
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Gets a long and detailed description of the tracked errors for the given <paramref name="messageId"/>
            consisting of time and full exception details for all registered exceptions
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetExceptions(System.String)">
            <summary>
            Gets all caught exceptions for the message ID
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.CleanUp(System.String)">
            <summary>
            Cleans up whichever tracking wr have done for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Dispose">
            <summary>
            Stops the periodic cleanup of tracked messages
            </summary>
        </member>
        <member name="T:Rebus.Retry.FailFast.FailFastChecker">
            <summary>
            Implementation of <seealso cref="T:Rebus.Retry.FailFast.IFailFastChecker"/> that determines that if an exception is
            <seealso cref="T:Rebus.Exceptions.FailFastException"/>, it should fail fast. Children of this class could
            further define additional logic to check if a message with exception should fail fast.
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.FailFastChecker.ShouldFailFast(System.String,System.Exception)">
            <summary>
            Checks if a message with exception should fail fast
            </summary>
        </member>
        <member name="T:Rebus.Retry.FailFast.FailFastStep">
            <summary>
            Incoming message pipeline step that implements a fail-fast mechanism - if the message has failed once
            with a specific exceptions, it get marked as "failed too many times". This allows the <seealso cref="T:Rebus.Retry.Simple.SimpleRetryStrategyStep"/>
            to send the message to the error queue.
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.FailFastStep.#ctor(Rebus.Retry.IErrorTracker,Rebus.Retry.FailFast.IFailFastChecker)">
            <summary>
            Constructs the step, using the given error tracker
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.FailFastStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks if there are any registered exceptions to the current message and
            if all of them are <see cref="T:Rebus.Exceptions.FailFastException"/>, then mark the message
            as failed too many times.
            </summary>
        </member>
        <member name="T:Rebus.Retry.FailFast.IFailFastChecker">
            <summary>
            Service to check if a message should fail fast
            </summary>
        </member>
        <member name="M:Rebus.Retry.FailFast.IFailFastChecker.ShouldFailFast(System.String,System.Exception)">
            <summary>
            Checks if a message with specific exception should fail fast
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorHandler">
            <summary>
            Serivce that gets to handle failed messages
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorHandler.HandlePoisonMessage(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext,System.Exception)">
            <summary>
            Handles the poisonous message in the right way
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorTracker">
            <summary>
            Service that is responsible for tracking errors across message deliveries.
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.RegisterError(System.String,System.Exception,System.Boolean)">
            <summary>
            This method is called on each experienced failed delivery. The <paramref name="final"/> flag
            can be set to true if this error is to be considered the final delivery attempt, meaning
            that the error tracker should immediately max out its internal counter (or whatever it is
            doing), resulting in <see cref="M:Rebus.Retry.IErrorTracker.HasFailedTooManyTimes(System.String)"/> yielding true from now on
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.CleanUp(System.String)">
            <summary>
            This method is called when there's no need to track the error anymore
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether the given message ID has had too many error registered for it
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetShortErrorDescription(System.String)">
            <summary>
            Should get a short error description for the message ID (i.e. something like "5 failed deliveries")
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Should get a full, detailed error description for the message ID (i.e. could be timestamps and full stack traces for all failed deliveries)
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetExceptions(System.String)">
            <summary>
            Gets all caught exceptions for the message ID
            </summary>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategy">
            <summary>
            Determines the retry strategy by providing an implementation of <see cref="T:Rebus.Retry.IRetryStrategyStep"/> which will be
            put in front of the incoming message pipeline
            </summary>
        </member>
        <member name="M:Rebus.Retry.IRetryStrategy.GetRetryStep">
            <summary>
            Should return a <see cref="T:Rebus.Retry.IRetryStrategyStep"/> which is an <see cref="T:Rebus.Pipeline.IIncomingStep"/> that implements the retry strategy
            </summary>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategyStep">
            <summary>
            Special marker for the retry strategy step
            </summary>
        </member>
        <member name="T:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler">
            <summary>
            Default <see cref="T:Rebus.Retry.IErrorHandler"/> that uses a "poison queue" to function as storage for failed messages.
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler.#ctor(Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the error handler
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler.Initialize">
            <summary>
            Initializes the poison queue error handler by creating the error queue if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler.HandlePoisonMessage(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext,System.Exception)">
            <summary>
            Handles the poisonous message by forwarding it to the configured error queue
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.FailedMessageWrapper`1">
            <summary>
            Wraps a failed message that is to be retried
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Exceptions">
            <summary>
            Gets all exceptions that were caught leading to this <see cref="T:Rebus.Retry.Simple.IFailed`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.FailedMessageWrapper`1.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},`0,System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Constructs the wrapper with the given message
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.FailedMessageWrapper`1.ToString">
            <summary>
            Returns a string that represents the current failed message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.IFailed`1">
            <summary>
            Interface of the wrapper of a failed message
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Exceptions">
            <summary>
            Gets all exceptions that were caught leading to this failed message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategy">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IRetryStrategy"/> that tracks errors in memory
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategy.#ctor(Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Retry.IErrorTracker,Rebus.Retry.IErrorHandler)">
            <summary>
            Constructs the retry strategy with the given settings, creating an error queue with the configured name if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategy.GetRetryStep">
            <summary>
            Gets the retry step with appropriate settings for this <see cref="T:Rebus.Retry.Simple.SimpleRetryStrategy"/>
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategyConfigurationExtensions">
            <summary>
            Configuration extensions for the simple retry strategy
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyConfigurationExtensions.SimpleRetryStrategy(Rebus.Config.OptionsConfigurer,System.String,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Configures the simple retry strategy, using the specified error queue address and number of delivery attempts
            </summary>
            <param name="optionsConfigurer">(extension method target)</param>
            <param name="errorQueueAddress">Specifies the name of the error queue</param>
            <param name="maxDeliveryAttempts">Specifies how many delivery attempts should be made before forwarding a failed message to the error queue</param>
            <param name="secondLevelRetriesEnabled">Specifies whether second level retries should be enabled - when enabled, the message will be dispatched wrapped in an <see cref="T:Rebus.Retry.Simple.IFailed`1"/> after the first <paramref name="maxDeliveryAttempts"/> delivery attempts, allowing a different handler to handle the message. Dispatch of the <see cref="T:Rebus.Retry.Simple.IFailed`1"/> is subject to the same <paramref name="maxDeliveryAttempts"/> delivery attempts</param>
            <param name="errorDetailsHeaderMaxLength">Specifies a MAX length of the error details to be enclosed as the <see cref="F:Rebus.Messages.Headers.ErrorDetails"/> header. As the enclosed error details can sometimes become very long (especially when using many delivery attempts), depending on the transport's capabilities it might sometimes be necessary to truncate the error details</param>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategySettings">
            <summary>
            Contains the settings used by <see cref="T:Rebus.Retry.Simple.SimpleRetryStrategy"/>
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultErrorQueueName">
            <summary>
            Name of the default error queue, which will be used unless <see cref="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorQueueAddress"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultNumberOfDeliveryAttempts">
            <summary>
            Number of delivery attempts that will be used unless <see cref="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.MaxDeliveryAttempts"/> is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategySettings.#ctor(System.String,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Creates the settings with the given error queue address and number of delivery attempts, defaulting to <see cref="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultErrorQueueName"/> and <see cref="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultNumberOfDeliveryAttempts"/> 
            as the error queue address and number of delivery attempts, respectively
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorQueueAddress">
            <summary>
            Name of the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.MaxDeliveryAttempts">
            <summary>
            Number of attempted deliveries to make before moving the poisonous message to the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.SecondLevelRetriesEnabled">
            <summary>
            Configures whether an additional round of delivery attempts should be made with a <see cref="T:Rebus.Retry.Simple.FailedMessageWrapper`1"/> wrapping the originally failed messageS
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorDetailsHeaderMaxLength">
            <summary>
            Configures the max length of the <see cref="F:Rebus.Messages.Headers.ErrorDetails"/> header. Depending on the configured number of delivery attempts and the transport's capabilities, it might
            be necessary to truncate the value of this header.
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategyStep">
            <summary>
            Incoming message pipeline step that implements a retry mechanism - if the call to the rest of the pipeline fails,
            the exception is caught and the queue transaction is rolled back. Caught exceptions are tracked in-mem, and after
            a configurable number of retries, the message will be forwarded to the configured error queue and the rest of the pipeline will not be called
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategyStep.DispatchAsFailedMessageKey">
            <summary>
            Key of a step context item that indicates that the message must be wrapped in a <see cref="T:Rebus.Retry.Simple.FailedMessageWrapper`1"/> after being deserialized
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyStep.#ctor(Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Retry.IErrorTracker,Rebus.Retry.IErrorHandler)">
            <summary>
            Constructs the step, using the given transport and settings
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the entire message processing pipeline in an exception handler, tracking the number of failed delivery attempts.
            Forwards the message to the error queue when the max number of delivery attempts has been exceeded.
            </summary>
        </member>
        <member name="T:Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions">
            <summary>
            Configuration extensions for configuring automatic forwarding on certain exception types
            </summary>
        </member>
        <member name="M:Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions.ForwardOnException``1(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.String,Rebus.Logging.LogLevel,System.Func{``0,System.Boolean})">
            <summary>
            Short-circuits the usual retry strategy by immediately forwarding the transport message to the specified queue when an
            exception of the type specified by <typeparamref name="TException"/> is caught. Please note that any outgoing message
            that have already been sent WILL BE SENT because the queue transaction is not rolled back.
            Use <paramref name="logLevel"/> to specify which log level to use when logging the forwarding action.
            </summary>
        </member>
        <member name="T:Rebus.Routing.IRouter">
            <summary>
            Abstraction of the routing logic. Should be capable of returning a destination address for a message
            and an owner address for a topic.
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Called when sending messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)">
            <summary>
            Called when subscribing to messages
            </summary>
        </member>
        <member name="T:Rebus.Routing.Itinerary">
            <summary>
            Represents a list of destinations that the routing slip must visit
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.#ctor(System.String[])">
            <summary>
            Initializes the itinerary with the given list of <paramref name="destinationAddresses"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.Add(System.String)">
            <summary>
            Adds the given <paramref name="destinationAddress"/> to the itinerary
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.ReturnTo(System.String)">
            <summary>
            Indicates that the routing slip must be returned to <paramref name="destinationAddress"/> when done
            </summary>
        </member>
        <member name="M:Rebus.Routing.Itinerary.ReturnToSender">
            <summary>
            Indicates that the routing slip must be returned to the sender when done
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ActionType.None">
            <summary>
            Doesn't do anything - dispatches the message as normally
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ActionType.Forward">
            <summary>
            Forwards the message to one or more recipients
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ActionType.Ignore">
            <summary>
            Ignores the message (thus effectively losing it)
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ErrorBehavior">
            <summary>
            Options on how to handle exceptions when attempting to forward transport messages
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ErrorBehavior.RetryForever">
            <summary>
            Indicates that no error handling should be done. This puts the burden of handling errors into the hands
            of the implementor of the transport message forwarding function, and thus it should handle errors by
            forwarding the message somewhere else
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ErrorBehavior.ForwardToErrorQueue">
            <summary>
            Indicates that the transport message should be forwarded to the error queue in the event that there is an error.
            This is done in a "fail fast"-fashion, so there will be no additional delivery attempts.
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardAction">
            <summary>
            Represents some action to perform with the incoming transport message. Must be created via the static functions
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ForwardAction.None">
            <summary>
            Gets an action that causes the message to be handled normally
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.ForwardTo(System.String)">
            <summary>
            Gets an action that causes the message to be forwarded to the queue specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.ForwardTo(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets an action that causes the message to be forwarded to the queues specified by <paramref name="destinationAddresses"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.Ignore">
            <summary>
            Gets an action that causes the messge to be ignored. THIS WILL EFFECTIVELY LOSE THE MESSAGE
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardTransportMessageStep">
            <summary>
            Incoming message step that looks at the transport message and possibly forwards it to another queue
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.#ctor(System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}},Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory,System.String,Rebus.Routing.TransportMessages.ErrorBehavior)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Invokes the routing function and performs some action depending on the returned <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> result
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions">
            <summary>
            Configuration extensions for very fast filtering and forwarding of incoming transport messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions.AddTransportMessageForwarder(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}})">
            <summary>
            Adds the given routing function - should return <see cref="F:Rebus.Routing.TransportMessages.ForwardAction.None"/> to do nothing, or another action
            available on <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> in order to do something to the message
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions.AddTransportMessageForwarder(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}},Rebus.Routing.TransportMessages.ErrorBehavior)">
            <summary>
            Adds the given routing function - should return <see cref="F:Rebus.Routing.TransportMessages.ForwardAction.None"/> to do nothing, or another action
            available on <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> in order to do something to the message
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouter">
            <summary>
            Routing logic that maps types to owning endpoints.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the router
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapFallback(System.String)">
            <summary>
            Configures <paramref name="destinationAddress"/> as a fallback which will be returned when trying to get a destination for an unmapped type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Gets the destination address for the given message
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetOwnerAddress(System.String)">
            <summary>
            Looks up the owner of the topic which is assumed to be an assembly-qualified name of an available .NET type
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions">
            <summary>
            Configuration extensions for configuring type-based routing (i.e. routing where each message type has one, single unambiguous
            owning endpoint)
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBased(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter})">
            <summary>
            Configures Rebus to use type-based routing
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder">
            <summary>
            Type-based routing configuration builder that can be called fluently to map message types to their owning endpoints
            </summary>
        </member>
        <member name="F:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder._configurationActions">
            <summary>
            We use this way of storing configuration actions in order to preserve the order
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapFallback(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as a fallback destination to use when none of the configured mappings match
            </summary>
        </member>
        <member name="T:Rebus.Sagas.CorrelationProperty">
            <summary>
            Represents a mapping from a field of an incoming message of a specific type to a specific property on a specific type of saga data
            </summary>
        </member>
        <member name="F:Rebus.Sagas.CorrelationProperty.AllowedCorrelationPropertyTypes">
            <summary>
            Defines the types that are allowed to use with saga data properties that are intended for correlation
            </summary>
        </member>
        <member name="M:Rebus.Sagas.CorrelationProperty.#ctor(System.Type,System.Func{Rebus.Pipeline.IMessageContext,System.Object,System.Object},System.Type,System.String,System.Type)">
            <summary>
            Constructs the correlation property
            </summary>
            <param name="messageType">Specifies the message type that this property can correlate</param>
            <param name="valueFromMessage">Specifies the function that will be called with the message instance in order to extract a value that should be used for correlation</param>
            <param name="sagaDataType">Specifies the type of saga data that this property can correlate to</param>
            <param name="propertyName">Specifies that property name on the saga data that this correlation addresses</param>
            <param name="sagaType">Specifies the saga type (i.e. the handler type) that contains the logic of the saga</param>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.MessageType">
            <summary>
            The message type that this property can correlate
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.ValueFromMessage">
            <summary>
            The function that will be called with the message instance in order to extract a value that should be used for correlation
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga's saga data
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.PropertyName">
            <summary>
            Gets the name of the correlation property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaType">
            <summary>
            The saga type (i.e. the handler type) that contains the logic of the saga
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions">
            <summary>
            Configuration extensions for optional in-process locking of saga instances
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions.EnforceExclusiveAccess(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage})">
            <summary>
            Forces exclusive access
            </summary>
        </member>
        <member name="T:Rebus.Sagas.IAmInitiatedBy`1">
            <summary>
            Derived marker interface, allowing for a handler to indicate that messages of type <typeparamref name="TMessage"/> 
            are allowed to instantiate new saga instances if the message cannot be correlated with an already existing instance
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ICorrelationConfig`1">
            <summary>
            Sets up the saga instance correlation configuration, i.e. it configures how the following question should be answered:
            "given this incoming message, how should Rebus figure out which saga instance should be loaded to handle it?"
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.Correlate``1(System.Func{``0,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/>, using the specified <paramref name="messageValueExtractorFunction"/> to
            extract a value from the message. The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            You could for example do something like this:
            <code>
            config.Correlate&lt;TradeApproved&gt;(t => t.Id, d => d.TradeId);
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "Id" property of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="messageValueExtractorFunction">Configures a function to extract a value from the message. Since this is just a function, it may contain logic that e.g. concatenates fields, calls other functions, etc.</param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateHeader``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/> using the header with the given <paramref name="headerKey"/>. The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            You could for example do something like this:
            <code>
            config.CorrelateHeader&lt;TradeApproved&gt;("trade-corr-id", d => d.TradeId);
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "trade-corr-id" header of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="headerKey">Configures a header key which will be extracted from the incoming message</param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.CorrelateContext``1(System.Func{Rebus.Pipeline.IMessageContext,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/> using the message context to get a value (e.g. by selecting certain headers, combining them, etc)
             The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="contextValueExtractorFunction">Configures a function that can extract a value from the current <see cref="T:Rebus.Pipeline.IMessageContext"/></param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotencyData">
            <summary>
            This chunk of data help with tracking handled messages and externally visible behavior (i.e. outbound messages) from handling each message
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.OutgoingMessages">
            <summary>
            Gets the outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.HandledMessageIds">
            <summary>
            Getst the IDs of all messages that have been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.HasAlreadyHandled(System.String)">
            <summary>
            Gets whether the message with the given ID has already been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.GetOutgoingMessages(System.String)">
            <summary>
            Gets the outgoing messages for the incoming message with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.MarkMessageAsHandled(System.String)">
            <summary>
            Marks the message with the given ID as handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.AddOutgoingMessage(System.String,System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Adds the <see cref="T:Rebus.Messages.TransportMessage"/> as an outgoing message destined for the addresses specified by <paramref name="destinationAddresses"/>
            under the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSaga`1">
            <summary>
            Sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> are sagas that guarantee idempotency by guarding against
            handling the same message twice by tracking IDs of handled messages
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions">
            <summary>
            Configuration extension for the idempotent sagas feature (allows for guaranteeing that a saga instance does not handle the same
            message twice, even in the face of at-least-once delivery guarantees and retries due to transport layer failures)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions.EnableIdempotentSagas(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables idempotent sagas. When enabled, sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> can be truly idempotent.
            This means that the saga instance stores the IDs of all handled messages, including all outgoing messages send when handling
            each incoming message - this way, the saga instance can guard itself against handling the same message twice, while still
            preserving externally visible behavior even when a message gets handled more than once.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaData">
            <summary>
            Convenient standard implementation of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep">
            <summary>
            Incoming pipeline step that checks the loaded saga data to see if the message currently being handled is a dupe.
            If it is, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message
            will be sent 
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks the loaded saga data to see if the message currently being handled is a duplicate of a message that has previously been handled. 
            If that is the case, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message will be sent.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep">
            <summary>
            Outgoing pipeline step that stores the sent message in the current saga data (if it is an <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IIdempotentSagaData">
            <summary>
            Derivation of <see cref="T:Rebus.Sagas.ISagaData"/> that is capable of storing externally visible side-effects (i.e. outgoing messages)
            that were caused by handling specific incoming messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IIdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessage">
            <summary>
            An outgoing message is a <see cref="T:Rebus.Messages.TransportMessage"/> destined for one or more destinations. It is meant to be stored
            in an <see cref="T:Rebus.Sagas.Idempotent.IdempotencyData"/> instance inside an instance of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessage.#ctor(System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the outgoing message destined for the given addresses
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.DestinationAddresses">
            <summary>
            Gets the addresses for which this <see cref="T:Rebus.Messages.TransportMessage"/> is supposed to be sent
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.TransportMessage">
            <summary>
            Gets the transport message
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessages">
            <summary>
            Contains all the <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances for a given incoming message
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.#ctor(System.String,System.Collections.Generic.IEnumerable{Rebus.Sagas.Idempotent.OutgoingMessage})">
            <summary>
            Constructs the instance for the given message ID, containing the given <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId">
            <summary>
            Gets the ID of the incoming message
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessagesToSend">
            <summary>
            Gets all the outgoing messages to be sent as a consequence of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.Add(Rebus.Sagas.Idempotent.OutgoingMessage)">
            <summary>
            Adds another <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> as a side-effect of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaCorrelationProperty">
            <summary>
            Represents a path to a correlation property on a saga of a specific type
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga data
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaData">
            <summary>
            Interface of a saga data instance. The saga data represents the state of the state machine instance of the process manager,
            that the saga essentially implements.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaStorage">
            <summary>
            Abstraction for a mechanism that is capable of storing saga state, retrieving it again by querying for value on the state
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Finds an already-existing instance of the given saga data type that has a property with the given <paramref name="propertyName"/>
            whose value matches <paramref name="propertyValue"/>. Returns null if no such instance could be found
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data as a new instance. Throws a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another saga data instance
            already exists with a correlation property that shares a value with this saga data.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the already-existing instance of the given saga data, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another
            saga data instance exists with a correlation property that shares a value with this saga data, or if the saga data
            instance no longer exists.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the saga data instance, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if the instance no longer exists
            </summary>
        </member>
        <member name="T:Rebus.Sagas.LoadSagaDataStep">
            <summary>
            Incoming step that loads and saves relevant saga data.
            </summary>
        </member>
        <member name="F:Rebus.Sagas.LoadSagaDataStep.IgnoredProperties">
            <summary>
            properties ignored by auto-setter (the one that automatically sets the correlation ID on a new saga data instance)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.LoadSagaDataStep.#ctor(Rebus.Sagas.ISagaStorage,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step with the given saga storage
            </summary>
        </member>
        <member name="M:Rebus.Sagas.LoadSagaDataStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            For each <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> found in the current <see cref="T:Rebus.Pipeline.IncomingStepContext"/>'s <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>,
            this step will see if the invoker's handler is actually a <see cref="T:Rebus.Sagas.Saga"/>. If that is the case, the saga's correlation properties
            are used to see if a piece of existing saga data can be retrieved and mounted on the <see cref="P:Rebus.Sagas.Saga`1.Data"/> property.
            If no existing instance was found, but the saga implements <see cref="T:Rebus.Sagas.IAmInitiatedBy`1"/> for the current message,
            a new saga data instance will be created (and mounted). Otherwise, the message is ignored.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga">
            <summary>
            Saga base class that allows for passing around saga instances without being bothered by the type of saga data they're handling. You should
            probably not inherit from this one, inherit your saga from <see cref="T:Rebus.Sagas.Saga`1"/> instead.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.UserHasOverriddenConflictResolutionMethod">
            <summary>
            Checks whether the <see cref="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)"/> method is defined in <see cref="T:Rebus.Sagas.Saga`1"/>, returning
            true if it is NOT - because that means that the user has overridden the method and in this particular saga type can resolve conflicts. 
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsComplete">
            <summary>
            Marks the current saga instance as completed, which means that it is either a) deleted from persistent storage in case
            it has been made persistent, or b) thrown out the window if it was never persisted in the first place.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsUnchanged">
            <summary>
            Marks the current saga instance as unchanged, causing any changes made to it to be ignored. Its revision will NOT be
            incremented
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga.IsNew">
            <summary>
            Gets whether the saga data instance is new
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga`1">
            <summary>
            Generic saga base class that must be made concrete by supplying the <typeparamref name="TSagaData"/> type parameter.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga`1.Data">
            <summary>
            Gets or sets the relevant saga data instance for this saga handler
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.CorrelateMessages(Rebus.Sagas.ICorrelationConfig{`0})">
            <summary>
            This method must be implemented in order to configure correlation of incoming messages with existing saga data instances.
            Use the injected <see cref="T:Rebus.Sagas.ICorrelationConfig`1"/> to set up the correlations, e.g. like so:
            <code>
            config.Correlate&lt;InitiatingMessage&gt;(m => m.OrderId, d => d.CorrelationId);
            config.Correlate&lt;CorrelatedMessage&gt;(m => m.CorrelationId, d => d.CorrelationId);
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)">
            <summary>
            Override this to be given an opportunity to resolve the conflict when a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> occurs on an update.
            If a conflict cannot be resolved, feel free to bail out by throwing an exception.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaData">
            <summary>
            Convenient implementation of <see cref="T:Rebus.Sagas.ISagaData"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaDataCorrelationProperties">
            <summary>
            Contains a set of correlation properties relevant for one particular saga data
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.#ctor(System.Collections.Generic.Dictionary{System.Type,Rebus.Sagas.CorrelationProperty[]},System.Type)">
            <summary>
            Constructs the set
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.ForMessage(System.Object)">
            <summary>
            Looks up correlation properties relevant for the specified message type
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.GetEnumerator">
            <summary>
            Gets the correlation properties contained in this collection
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaHelper">
            <summary>
            Helper class that can cache configured sets of correlation properties for various saga types
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.GetCorrelationProperties(System.Object,Rebus.Sagas.Saga)">
            <summary>
            Gets (most likely from a cache) the set of correlation properties relevant for the given saga handler.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.CreateNewSagaData(Rebus.Sagas.Saga)">
            <summary>
            Creates a new instance of the saga's saga data
            </summary>
        </member>
        <member name="T:Rebus.Serialization.DictionarySerializer">
            <summary>
            Generic serializer that serializes <see cref="T:System.Collections.Generic.Dictionary`2"/> of <see cref="T:System.String"/> keys and <see cref="T:System.String"/> values
            into JSON and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.SerializeToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Serializes the given dictionary into a JSON string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.DeserializeFromString(System.String)">
            <summary>
            Deserializes the given JSON string into a dictionary
            </summary>
        </member>
        <member name="T:Rebus.Serialization.GenericJsonSerializer">
            <summary>
            Generic serializer that serializes an object into a string and vice versa. Uses a normal, compact JSON format,
            requiring the serialized type to be known at deserialization time
            </summary>
        </member>
        <member name="M:Rebus.Serialization.GenericJsonSerializer.Serialize``1(``0)">
            <summary>
            Serializes the given object to a string. No type information is included - therefore, abstract members etc.
            cannot be reproduced when deserializing
            </summary>
        </member>
        <member name="M:Rebus.Serialization.GenericJsonSerializer.Deserialize``1(System.String)">
            <summary>
            Deserializes the given JSON string to the type specified
            </summary>
        </member>
        <member name="T:Rebus.Serialization.HeaderSerializer">
            <summary>
            Simple serializer that can be used to encode/decode headers to/from bytes
            </summary>
        </member>
        <member name="P:Rebus.Serialization.HeaderSerializer.Encoding">
            <summary>
            Configures which encoding to use for encoding the string of headers to/from bytes
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.SerializeToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Encodes the headers into a string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.Serialize(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Encodes the headers into a byte array
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.Deserialize(System.Byte[])">
            <summary>
            Decodes the headers from the given byte array
            </summary>
        </member>
        <member name="M:Rebus.Serialization.HeaderSerializer.DeserializeFromString(System.String)">
            <summary>
            Decodes the headers from the given string
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ISerializer">
            <summary>
            Message serializer that should capable of safely roundtripping .NET message body objects to some serialized form and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.JsonSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.Serialization.ISerializer"/> that uses Newtonsoft JSON.NET internally, with some pretty robust settings
            (i.e. full type info is included in the serialized format in order to support deserializing "unknown" types like
            implementations of interfaces, etc)
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.JsonSerializer.JsonUtf8ContentType">
            <summary>
            Proper content type when a message has been serialized with this serializer (or another compatible JSON serializer) and it uses the standard UTF8 encoding
            </summary>
        </member>
        <member name="F:Rebus.Serialization.Json.JsonSerializer.JsonContentType">
            <summary>
            Contents type when the content is JSON
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonSerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions">
            <summary>
            Configuration extensions for the honest Newtonsoft JSON.NET-based Rebus message serializer
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions.UseNewtonsoftJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer})">
            <summary>
            Configures Rebus to use Newtonsoft JSON.NET to serialize messages, using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> that includes ALL
            type information in every object, thus allowing for preserving all type information when roundtripping message types.
            Message bodies are UTF8-encoded.
            This is the default message serialization, so there is actually no need to call this method.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions.UseNewtonsoftJson(Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer},Newtonsoft.Json.JsonSerializerSettings,System.Text.Encoding)">
            <summary>
            Configures Rebus to use Newtonsoft JSON.NET to serialize messages, using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> and 
            This allows you to customize almost every aspect of how messages are actually serialized/deserialized.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ObjectSerializer">
            <summary>
            Generic serializer that happily serializes rich objects. Uses JSON.NET internally with full type information.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Serialize(System.Object)">
            <summary>
            Serializes the given object into a byte[]
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.SerializeToString(System.Object)">
            <summary>
            Serializes the given object into a string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes the given byte[] into an object
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.DeserializeFromString(System.String)">
            <summary>
            Deserializes the given string into an object
            </summary>
        </member>
        <member name="T:Rebus.Subscriptions.ISubscriptionStorage">
            <summary>
            Abstraction that handles how subscriptions are stored
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.FakeBusDisposed">
            <summary>
            Indicates that the bus was disposed
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.FakeBusEvent">
            <summary>
            Base type of all events that a <see cref="T:Rebus.Testing.FakeBus"/> can record.
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.FakeBusEvent.Time">
            <summary>
            Gets the time of when the event was recorded
            </summary>
        </member>
        <member name="M:Rebus.Testing.Events.FakeBusEvent.ToString">
            <summary>
            Gets a nice string representation of this particular fake bus event
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageDeferred">
            <summary>
            Recorded when a message was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred.Delay">
            <summary>
            Gets the time span with which this message was delayed
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred.CommandMessage">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageDeferred`1">
            <summary>
            Recorded when a message was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred`1.CommandMessage">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageDeferredToSelf">
            <summary>
            Recorded when a message was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferredToSelf.Delay">
            <summary>
            Gets the time span with which this message was delayed
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferredToSelf.CommandMessage">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferredToSelf.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageDeferredToSelf`1">
            <summary>
            Recorded when a message was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferredToSelf`1.CommandMessage">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessagePublished">
            <summary>
            Recorded when an event was published
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessagePublished.EventMessage">
            <summary>
            Gets the event message that was published
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessagePublished.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessagePublished`1">
            <summary>
            Recorded when an event was published
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessagePublished`1.EventMessage">
            <summary>
            Gets the event message that was published
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSent">
            <summary>
            Base event recorded when a message was sent - actual event will be <see cref="T:Rebus.Testing.Events.MessageSent`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSent.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSent.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSent`1">
            <summary>
            Recorded when a message was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSent`1.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSentToSelf">
            <summary>
            Recorded when a message was sent to the bus' own input queue
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSentToSelf.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSentToSelf.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSentToSelf`1">
            <summary>
            Recorded when a message was sent to the bus' own input queue
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSentToSelf`1.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.ReplyMessageSent">
            <summary>
            Recorded when a reply message was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.ReplyMessageSent.ReplyMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.ReplyMessageSent.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.ReplyMessageSent`1">
            <summary>
            Recorded when a reply message was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.ReplyMessageSent`1.ReplyMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.Subscribed">
            <summary>
            Recorded when a subscription was made
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.Subscribed.EventType">
            <summary>
            Gets the type of event that was subscribed to
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.Unsubscribed">
            <summary>
            Recorded when a subscription was revoked
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.Unsubscribed.EventType">
            <summary>
            Gets the type of event that was unsubscribed to
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeAdvancedApi">
            <summary>
            Implementation of <see cref="T:Rebus.Bus.Advanced.IAdvancedApi"/> that can be used to set up fake implementations of various advanced bus APIs for running isolated tests
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeAdvancedApi.#ctor(Rebus.Bus.Advanced.IWorkersApi,Rebus.Bus.Advanced.ITopicsApi,Rebus.Bus.Advanced.IRoutingApi,Rebus.Bus.Advanced.ITransportMessageApi,Rebus.DataBus.IDataBus,Rebus.Bus.Advanced.ISyncBus)">
            <summary>
            Creates the fake advanced API, using the given implementation(s). All arguments are optional
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeAdvancedApi.Workers">
            <summary>
            Gets the workers API if one was passed to the constructor, or throws an exception if that is not the case
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeAdvancedApi.Topics">
            <summary>
            Gets the topics API if one was passed to the constructor, or throws an exception if that is not the case
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeAdvancedApi.Routing">
            <summary>
            Gets the routing API if one was passed to the constructor, or throws an exception if that is not the case
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeAdvancedApi.TransportMessage">
            <summary>
            Gets the transport message API if one was passed to the constructor, or throws an exception if that is not the case
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeAdvancedApi.DataBus">
            <summary>
            Gets the data bus API if one was passed to the constructor, or throws an exception if that is not the case
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeAdvancedApi.SyncBus">
            <summary>
            Exposes a synchronous version of <see cref="T:Rebus.Bus.IBus"/> that essentially mimics all APIs only providing them in an synchronous version
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeBus">
            <summary>
            The fake bus is an implementation of <see cref="T:Rebus.Bus.IBus"/> that can be used for testing. The fake bus
            just collects information about what has happened to it, allowing you to query that information after the
            fact by checking <see cref="P:Rebus.Testing.FakeBus.Events"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Events">
             <summary>
             Gets all events recorded at this point. Query this in order to check what happened to the fake bus while
             it participated in a test - e.g. like this:
             <code>
             await fakeBus.Send(new MyMessage("woohoo!"));
            
             var sentMessagesWithMyGreeting = fakeBus.Events
                 .OfType&lt;MessageSent&lt;MyMessage&gt;&gt;()
                 .Count(m => m.CommandMessage.Text == "woohoo!");
            
             Assert.That(sentMessagesWithMyGreeting, Is.EqualTo(1));
             </code>
             </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.On``1(System.Action{``0})">
            <summary>
            Adds a callback to be invoked when new events are recorded in the fake bus
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Clear">
            <summary>
            Clears all events recorded by the fake bus. Registered callbacks will NOT be cleared
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="P:Rebus.Testing.FakeBus.Advanced">
            <summary>
            Gets the advanced API. An implementation of <see cref="T:Rebus.Bus.Advanced.IAdvancedApi"/> must either be passed to the contructor, or one must be set using the
            <see cref="P:Rebus.Testing.FakeBus.Advanced"/> property before calling the getter, otherwise an <see cref="T:System.InvalidOperationException"/> is thrown.
            Check out <see cref="T:Rebus.Testing.FakeAdvancedApi"/> for an easy way to pass your own implementations of e.g. <see cref="T:Rebus.Bus.Advanced.ISyncBus"/> etc.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Subscribe``1">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Subscribe(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Unsubscribe``1">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Unsubscribe(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeBus.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Rebus.Testing.FakeDataBus">
            <summary>
            Test helper that can be used to fake the presence of a configured data bus, using the given in-mem data store to store data
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeDataBus.EstablishContext(Rebus.DataBus.InMem.InMemDataStore)">
            <summary>
            Establishes a fake presence of a configured data bus, using the given <see cref="T:Rebus.DataBus.InMem.InMemDataStore"/> to retrieve data
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeDataBus.#ctor(Rebus.DataBus.InMem.InMemDataStore)">
            <summary>
            Creates the fake data bus, optionally using the given in-mem data store to store attachments
            </summary>
            <param name="dataStore"></param>
        </member>
        <member name="M:Rebus.Testing.FakeDataBus.CreateAttachment(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeDataBus.OpenRead(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeDataBus.GetMetadata(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Rebus.Testing.FakeSyncBus">
            <summary>
            The fake sync bus is an implementation of <see cref="T:Rebus.Bus.Advanced.ISyncBus"/> that can be used for testing. The fake bus
            just collects information about what has happened to it, allowing you to query that information after the
            fact by checking <see cref="P:Rebus.Testing.FakeSyncBus.Events"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeSyncBus.Events">
             <summary>
             Gets all events recorded at this point. Query this in order to check what happened to the fake bus while
             it participated in a test - e.g. like this:
             <code>
             await fakeBus.Send(new MyMessage("woohoo!"));
            
             var sentMessagesWithMyGreeting = fakeBus.Events
                 .OfType&lt;MessageSent&lt;MyMessage&gt;&gt;()
                 .Count(m => m.CommandMessage.Text == "woohoo!");
            
             Assert.That(sentMessagesWithMyGreeting, Is.EqualTo(1));
             </code>
             </summary>
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.On``1(System.Action{``0})">
            <summary>
            Adds a callback to be invoked when new events are recorded in the fake bus
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Clear">
            <summary>
            Clears all events recorded by the fake bus. Registered callbacks will NOT be cleared
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.DeferLocal(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Subscribe``1">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Subscribe(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Unsubscribe``1">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Unsubscribe(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Rebus.Testing.FakeSyncBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <inheritdoc />
        </member>
        <member name="T:Rebus.Testing.Internals.LockStepper">
            <summary>
            Pipeline step that makes it easy to block message processing until some particular point in time.
            This is done by adding a <see cref="T:System.Threading.ManualResetEvent"/> to it, which will be set the next time
            a message has been processed
            </summary>
        </member>
        <member name="T:Rebus.Testing.LogEvent">
            <summary>
            Represents a log event emitted from Rebus' internals during saga testing with <see cref="T:Rebus.Testing.SagaFixture`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.Time">
            <summary>
            Gets the (Rebus) time of when the event was emitted
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.Level">
            <summary>
            Gets the associated log level
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.Text">
            <summary>
            Gets a string representation of the log event
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.ExceptionOrNull">
            <summary>
            Gets the associated exception (or null if none was included)
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.SourceType">
            <summary>
            Gets the type that the logger was associated with
            </summary>
        </member>
        <member name="M:Rebus.Testing.LogEvent.ToString">
            <summary>
            Gets a string-formatted version of the log event
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture">
            <summary>
            Saga fixture factory class - can be used to create an appropriate <see cref="T:Rebus.Testing.SagaFixture`1"/> for a saga
            handler to participate in white-box testing scenarios
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture.For``1">
            <summary>
            Creates a saga fixture for the specified saga handler, which must have a default constructor. If the saga handler
            requires any parameters to be created, use the <see cref="M:Rebus.Testing.SagaFixture.For``1(System.Func{``0})"/> overload that
            accepts a factory function as a saga handler instance creator
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture.For``1(System.Func{``0})">
            <summary>
            Creates a saga fixture for the specified saga handler, which will be instantiated by the given factory method
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture.For``1(System.Func{Rebus.Config.RebusConfigurer})">
            <summary>
            Creates a saga fixture for the specified saga handler, which will be instantiated by the given factory method
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1">
            <summary>
            Saga fixture that wraps an in-mem Rebus that 
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Correlated">
            <summary>
            Event that is raised whenever a message could be successfully correlated with a saga data instance. The instance
            is passed to the event handler
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CouldNotCorrelate">
            <summary>
            Event that is raised whenever a message could NOT be successfully correlated with a saga data instance. The event is
            raised regardless of whether the incoming message is allowed to initiate a new saga or not.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Created">
            <summary>
            Event that is raised when the incoming message resulted in creating a new saga data instance. The created instance
            is passed to the event handler.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Updated">
            <summary>
            Event that is raised when the incoming message resulted in updating an existing saga data instance. The updated instance
            is passed to the event handler.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Deleted">
            <summary>
            Event that is raised when the incoming message resulted in deleting an existing saga data instance. The deleted instance
            is passed to the event handler.
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.Data">
            <summary>
            Gets all of the currently existing saga data instances
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.LogEvents">
            <summary>
            Gets all log events emitted by the internal Rebus instance
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Deliver(System.Object,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
            <summary>
            Delivers the given message to the saga handler
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Add(Rebus.Sagas.ISagaData)">
            <summary>
            Adds the given saga data to the available saga data in the saga fixture. If the saga data is not provided
            with an ID, a new guid will automatically be assigned internally.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.AddRange(System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaData})">
            <summary>
            Adds the given saga data instances to the available saga data in the fixture. If the saga data instances have not been provided
            with an ID, a new guid will automatically be assigned internally.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Dispose">
            <summary>
            Shuts down the in-mem bus that holds the saga handler
            </summary>
        </member>
        <member name="T:Rebus.Threading.AsyncBottleneck">
            <summary>
            The "bottleneck" is a wrapper around <see cref="T:System.Threading.SemaphoreSlim"/> that makes it easy to decrese the count of a semaphore,
            increasing it again after having used it.
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.#ctor(System.Int32)">
            <summary>
            Constructs the bottleneck, allowing for <paramref name="maxParallelOperationsToAllow"/> parallel operations
            to be performed
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.Enter(System.Threading.CancellationToken)">
            <summary>
            Grabs the semaphore and releases an <see cref="T:System.IDisposable"/> that will release it again when disposed
            </summary>
        </member>
        <member name="T:Rebus.Threading.IAsyncTask">
            <summary>
            A task that will be executed periodically. Starts executing as soon as <see cref="M:Rebus.Threading.IAsyncTask.Start"/>
            is called, beginning with waiting the full interval before the first execution. Stops running when it is disposed.
            </summary>
        </member>
        <member name="M:Rebus.Threading.IAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="T:Rebus.Threading.IAsyncTaskFactory">
            <summary>
            Factory that is capable of creating lightweight async tasks for doing background work
            </summary>
        </member>
        <member name="M:Rebus.Threading.IAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager">
            <summary>
            Helper that counts the number of parallel operations. Not reentrant, this bad boy is meant to be used from a single worker thread
            that may use it to count the number of async parallel operations waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.#ctor(System.Int32)">
            <summary>
            Constructs the container with the given max number of parallel async operations to allow
            </summary>
        </member>
        <member name="P:Rebus.Threading.ParallelOperationsManager.HasPendingTasks">
            <summary>
            Gets whether any async tasks are currently waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.TryBegin">
            <summary>
            Begins another async operation and returns an <see cref="T:System.IDisposable"/> that must be disposed in order to mark the end of the async operation
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager.ParallelOperation">
            <summary>
            Gets a disposable token for the parallel operation - the token indicates whether it's ok to continue
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.Dispose">
            <summary>
            Ends this parallel operation
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.CanContinue">
            <summary>
            Gets whether the token was successfully acquired
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTask"/> that uses a <see cref="T:System.Threading.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="F:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses a <see cref="T:System.Threading.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.TaskParallelLibrary.TplAsyncTask">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/>-based background timer thingie, that will periodically call an async <see cref="T:System.Func`1"/>
             </summary>
        </member>
        <member name="F:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses TPL to execute the background task
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates a new TPL-based async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessage">
            <summary>
            Represents a message that was deferred and is now due. The message has some headers and a body and can be turned into
            a <see cref="T:Rebus.Messages.TransportMessage"/> by calling <see cref="M:Rebus.Timeouts.DueMessage.ToTransportMessage"/>. The due message can be constructed in a
            way that can perform an arbitrary action in order to mark the due message as successfully delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[],System.Func{System.Threading.Tasks.Task})">
            <summary>
            Constructs the due message with the given headers and body, storing the given <paramref name="completeAction"/> to be
            executed when the message's <see cref="M:Rebus.Timeouts.DueMessage.MarkAsCompleted"/> method is called.
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Headers">
            <summary>
            Gets the headers of this due message
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Body">
            <summary>
            Gets the body data of this due message
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.MarkAsCompleted">
            <summary>
            Marks the due message as successfully handled, which should probably be done when the message has been safely sent to the proper recipient
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.ToTransportMessage">
            <summary>
            Returns the headers and the body of this due message in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessagesResult">
            <summary>
            Represents the result of calling <see cr